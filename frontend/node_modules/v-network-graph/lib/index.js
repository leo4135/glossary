var Io = Object.defineProperty, Lo = Object.defineProperties;
var $o = Object.getOwnPropertyDescriptors;
var on = Object.getOwnPropertySymbols;
var Ao = Object.prototype.hasOwnProperty, Zo = Object.prototype.propertyIsEnumerable;
var ie = Math.pow, sn = (n, e, t) => e in n ? Io(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, oe = (n, e) => {
  for (var t in e || (e = {}))
    Ao.call(e, t) && sn(n, t, e[t]);
  if (on)
    for (var t of on(e))
      Zo.call(e, t) && sn(n, t, e[t]);
  return n;
}, Be = (n, e) => Lo(n, $o(e));
var pe = (n, e, t) => new Promise((o, i) => {
  var s = (u) => {
    try {
      c(t.next(u));
    } catch (h) {
      i(h);
    }
  }, a = (u) => {
    try {
      c(t.throw(u));
    } catch (h) {
      i(h);
    }
  }, c = (u) => u.done ? o(u.value) : Promise.resolve(u.value).then(s, a);
  c((t = t.apply(n, e)).next());
});
import { isReactive as Do, reactive as Ee, provide as Me, inject as Ce, watch as F, toRef as we, watchEffect as ue, computed as O, unref as M, ref as j, onMounted as je, onUnmounted as Xe, nextTick as At, defineComponent as U, createElementBlock as I, openBlock as S, createCommentVNode as ae, createBlock as W, resolveDynamicComponent as _n, Fragment as X, renderList as Q, mergeProps as ne, renderSlot as K, withModifiers as ve, normalizeClass as ce, normalizeStyle as Ge, useAttrs as No, createElementVNode as In, createTextVNode as jo, toDisplayString as rn, createVNode as Ie, withCtx as te, useSlots as st, createSlots as Zt, normalizeProps as Ot, guardReactiveProps as zt, TransitionGroup as Fe, toHandlers as Bo, readonly as Re } from "vue";
import { isEqual as Pe, round as an, merge as Ln, mergeWith as Ro, isPlainObject as Vo, debounce as Wo, uniq as Ho, chunk as Dt } from "lodash-es";
const Uo = [
  "paths",
  "node-labels",
  "nodes",
  "focusring",
  "edge-labels",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
function xe(n) {
  return Do(n) ? n : Ee(n);
}
function q(n, e = "Parameter") {
  if (n == null)
    throw new Error(`${e} is null`);
  return n;
}
const $n = Symbol("containers");
function Fo(n) {
  Me($n, n);
}
function Nt() {
  const n = q(Ce($n), "containers");
  return {
    container: n.container,
    svg: n.svg,
    viewport: n.viewport,
    svgPanZoom: n.svgPanZoom
  };
}
class _ {
  static value(e, t) {
    return e instanceof Function ? e(t) : e;
  }
  static values(e, t) {
    return Object.values(e).filter((o) => o instanceof Function).length === 0 ? e : Object.fromEntries(
      Object.entries(e).map(([o, i]) => [o, i instanceof Function ? i(t) : i])
    );
  }
}
var D = /* @__PURE__ */ ((n) => (n.CENTER = "center", n.NORTH = "north", n.NORTH_EAST = "north-east", n.EAST = "east", n.SOUTH_EAST = "south-east", n.SOUTH = "south", n.SOUTH_WEST = "south-west", n.WEST = "west", n.NORTH_WEST = "north-west", n))(D || {});
function bt(n) {
  const e = {};
  return Object.assign(e, n(e));
}
function qr(n) {
  return n;
}
function Xr(n) {
  return n;
}
function ln(n, e, t) {
  const o = _.values(e.normal, n);
  return o.type == "circle" ? {
    width: o.radius * 2 * t,
    height: o.radius * 2 * t
  } : {
    width: o.width * t,
    height: o.height * t
  };
}
function qo(n, e, t, o) {
  const s = Math.abs(n.x - t.x) < e.width / 2 + o.width / 2, c = Math.abs(n.y - t.y) < e.height / 2 + o.height / 2;
  return s && c;
}
function Ke(n, e) {
  let t = 0;
  return e === 1 || n === void 0 || n === "none" ? t = n != null ? n : 0 : typeof n == "string" ? t = n.split(/\s+/).map((o) => parseInt(o) * e).filter((o) => !isNaN(o)).join(" ") : t = n * e, t && t !== "0" ? t : void 0;
}
function rt(n) {
  let e = 0;
  if (n === void 0 || n === "none")
    e = 0;
  else if (typeof n == "string") {
    const t = n.split(/\s+/).map((o) => parseInt(o)).filter((o) => !isNaN(o));
    t.length % 2 === 0 ? e = t.reduce((o, i) => o + i, 0) : e = t.reduce((o, i) => o + i, 0) * 2;
  } else
    e = n * 2;
  return e;
}
const cn = 20;
class An {
  activate(e) {
    const { nodePositions: t, nodes: o, configs: i, emitter: s, scale: a, svgPanZoom: c } = e, u = (r) => {
      for (const [l, d] of Object.entries(r)) {
        const b = this.getOrCreateNodePosition(t, l);
        this.setNodePosition(b, d);
      }
    }, h = (r) => {
      const l = r.filter((k) => !(k in t.value)), d = c.getViewArea(), b = a.value;
      for (const k of l) {
        const g = o.value[k], v = ln(g, i.node, b), w = oe({}, d.center);
        for (; ; ) {
          let m = !1;
          for (const [p, y] of Object.entries(t.value)) {
            if (k === p) continue;
            const x = o.value[p];
            if (!x) continue;
            const z = ln(x, i.node, b);
            if (m = qo(w, v, y, z), m)
              break;
          }
          if (m)
            w.x += v.width + cn * b, w.x + v.width / 2 > d.box.right && (w.x = d.center.x, w.y += v.height + cn * b);
          else
            break;
        }
        const E = this.getOrCreateNodePosition(t, k);
        this.setNodePosition(E, w);
      }
    };
    h(Object.keys(o.value));
    const f = F(
      () => Pe(new Set(Object.keys(o.value)), new Set(Object.keys(t.value))),
      (r) => {
        r || h(Object.keys(o.value));
      }
    );
    s.on("node:dragstart", u), s.on("node:pointermove", u), s.on("node:dragend", u), this.onDeactivate = () => {
      f(), s.off("node:dragstart", u), s.off("node:pointermove", u), s.off("node:dragend", u);
    };
  }
  deactivate() {
    this.onDeactivate && this.onDeactivate();
  }
  setNodePosition(e, t) {
    e.value.x = an(t.x, 3), e.value.y = an(t.y, 3);
  }
  getOrCreateNodePosition(e, t) {
    const o = we(e.value, t);
    return o.value || (o.value = { x: 0, y: 0 }), o;
  }
}
function Zn() {
  return {
    view: {
      scalingObjects: !1,
      panEnabled: !0,
      zoomEnabled: !0,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      doubleClickZoomEnabled: !0,
      mouseWheelZoomEnabled: !0,
      boxSelectionEnabled: !1,
      autoPanAndZoomOnLoad: "center-content",
      fitContentMargin: "8%",
      autoPanOnResize: !0,
      layoutHandler: new An(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: !1,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      },
      selection: {
        box: {
          color: "#0000ff20",
          strokeWidth: 1,
          strokeColor: "#aaaaff",
          strokeDasharray: 0
        },
        detector: (n) => {
          const e = /Mac OS/.test(navigator.userAgent) ? n.metaKey : n.ctrlKey;
          return n.type === "keydown" ? e : !e;
        }
      },
      builtInLayerOrder: [],
      onBeforeInitialDisplay: void 0
    },
    node: bt((n) => ({
      normal: {
        type: "circle",
        radius: 16,
        // for rect -->
        width: 32,
        height: 32,
        borderRadius: 4,
        // <-- for rect
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (e) => _.value(n.normal.type, e),
        radius: (e) => {
          var t;
          return ((t = _.value(n.normal.radius, e)) != null ? t : 0) + 2;
        },
        width: (e) => {
          var t;
          return ((t = _.value(n.normal.width, e)) != null ? t : 0) + 2;
        },
        height: (e) => {
          var t;
          return ((t = _.value(n.normal.height, e)) != null ? t : 0) + 2;
        },
        borderRadius: (e) => {
          var t;
          return (t = _.value(n.normal.borderRadius, e)) != null ? t : 0;
        },
        strokeWidth: (e) => _.value(n.normal.strokeWidth, e),
        strokeColor: (e) => _.value(n.normal.strokeColor, e),
        strokeDasharray: (e) => _.value(n.normal.strokeDasharray, e),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: !0,
      selectable: !1,
      label: {
        visible: !0,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        direction: D.SOUTH,
        directionAutoAdjustment: !1,
        text: "name",
        handleNodeEvents: !0
      },
      focusring: {
        visible: !0,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    })),
    edge: bt((n) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: !1,
        animationSpeed: 50
      },
      hover: {
        width: (e) => _.value(n.normal.width, e) + 1,
        color: "#3355bb",
        dasharray: (e) => _.value(n.normal.dasharray, e),
        linecap: (e) => _.value(n.normal.linecap, e),
        animate: (e) => _.value(n.normal.animate, e),
        animationSpeed: (e) => _.value(n.normal.animationSpeed, e)
      },
      selected: {
        width: (e) => _.value(n.normal.width, e) + 1,
        color: "#dd8800",
        dasharray: (e) => {
          const t = _.value(n.normal.width, e);
          return `${t * 1.5} ${t * 2}`;
        },
        linecap: (e) => _.value(n.normal.linecap, e),
        animate: (e) => _.value(n.normal.animate, e),
        animationSpeed: (e) => _.value(n.normal.animationSpeed, e)
      },
      selectable: !1,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          offset: 0,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (e, t) => t.edge.type == "curve" ? !1 : null,
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          // for circle -->
          radius: 6,
          // <-- for circle
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: !1,
          animationSpeed: 50
        }
      },
      selfLoop: {
        radius: 12,
        isClockwise: !0,
        offset: 10,
        angle: 270
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        // background: {
        //   visible: true,
        //   color: "#ffffff",
        //   padding: {
        //     vertical: 1,
        //     horizontal: 4,
        //   },
        //   borderRadius: 2
        // },
        margin: 4,
        padding: 4
      },
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      }
    })),
    path: bt((n) => ({
      visible: !1,
      clickable: !1,
      hoverable: !1,
      curveInNode: !1,
      end: "centerOfNode",
      margin: 0,
      // @Deprecated
      path: Ee({
        width: 6,
        color: (e) => {
          const t = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ], o = e.edges.map(
            (i) => i.split("").reduce((s, a) => (s = (s << 5) - s + a.charCodeAt(0), s & s), 0)
          ).reduce((i, s) => i + s, 0);
          return t[Math.abs(o) % t.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: !1,
        animationSpeed: 50
      }),
      normal: {
        width: (e) => _.value(n.path.width, e),
        color: (e) => _.value(n.path.color, e),
        dasharray: (e) => _.value(n.path.dasharray, e),
        linecap: (e) => _.value(n.path.linecap, e),
        linejoin: (e) => _.value(n.path.linejoin, e),
        animate: (e) => _.value(n.path.animate, e),
        animationSpeed: (e) => _.value(n.path.animationSpeed, e)
      },
      hover: {
        width: (e) => _.value(n.normal.width, e) + 2,
        color: (e) => _.value(n.normal.color, e),
        dasharray: (e) => _.value(n.normal.dasharray, e),
        linecap: (e) => _.value(n.normal.linecap, e),
        linejoin: (e) => _.value(n.normal.linejoin, e),
        animate: (e) => _.value(n.normal.animate, e),
        animationSpeed: (e) => _.value(n.normal.animationSpeed, e)
      },
      selected: {
        width: (e) => _.value(n.normal.width, e) + 2,
        color: (e) => _.value(n.normal.color, e),
        dasharray: "6 12",
        linecap: (e) => _.value(n.normal.linecap, e),
        linejoin: (e) => _.value(n.normal.linejoin, e),
        animate: (e) => _.value(n.normal.animate, e),
        animationSpeed: (e) => _.value(n.normal.animationSpeed, e)
      },
      selectable: !1,
      zOrder: {
        enabled: !1,
        zIndex: 0,
        bringToFrontOnHover: !0,
        bringToFrontOnSelected: !0
      },
      transition: void 0
    }))
  };
}
function Gr(n) {
  const e = Zn();
  return n && Ln(e, n), e;
}
const Dn = Symbol("style");
function Xo(n, e) {
  return Vo(n) ? Ln(n, e) : e;
}
function Go(n) {
  const e = Ee(Zn()), t = Object.keys(e);
  for (const o of t)
    F(() => n.value[o], () => {
      Ro(e[o], n.value[o] || {}, Xo);
    }, { immediate: !0, deep: !0 });
  return Me(Dn, e), e;
}
function at(n) {
  return q(Ce(Dn), `Configs(${n})`)[n];
}
function Ko() {
  return at("view");
}
function lt() {
  return at("node");
}
function ct() {
  return at("edge");
}
function Nn() {
  return at("path");
}
let Yo = 1;
function Qo() {
  return Yo++;
}
function le(n) {
  return Object.entries(n);
}
function et(n, e) {
  const t = new Set(Object.keys(n));
  le(e).forEach(([o, i]) => {
    Pe(n[o], i) || (n[o] = i), t.delete(o);
  }), t.forEach((o) => delete n[o]);
}
function Jo(n) {
  return n instanceof Promise || n && typeof n.then == "function";
}
function ei(n, e, t) {
  const o = xe({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  return ue(() => {
    const { edgeLayoutPoints: i, edgeGroups: s } = ni(
      t,
      n.value,
      e.value
    );
    et(o.edgeLayoutPoints, i), et(o.edgeGroups, s);
  }), ue(() => {
    const i = {};
    for (const [s, { edges: a, groupWidth: c }] of Object.entries(o.edgeGroups)) {
      let u = !1;
      if (c == 0)
        u = !1;
      else if (t.edge.summarize instanceof Function) {
        const h = t.edge.summarize(a, t);
        h === null ? u = un(n.value, a, t, c) : u = h;
      } else t.edge.summarize ? u = un(n.value, a, t, c) : u = !1;
      o.edgeGroups[s].summarize = u, u && Object.keys(a).forEach((h) => i[h] = !0);
    }
    et(o.summarizedEdges, i);
  }), o;
}
function ti(n, e, t, o, i, s) {
  return n ? e ? dn(n.edge, t, o, i, 0, 0, s) : dn(
    n.edge,
    t,
    o,
    i,
    n.groupWidth,
    n.pointInGroup,
    s
  ) : { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } };
}
function ni(n, e, t) {
  const o = {}, i = {}, s = {};
  for (const [c, u] of Object.entries(t)) {
    if (!(u.source in e && u.target in e))
      continue;
    const h = [u.source, u.target].sort().join("<=>"), f = s[h] || {};
    f[c] = u, s[h] = f;
  }
  const a = n.edge.gap instanceof Function ? n.edge.gap : (c, u) => n.edge.gap;
  for (const [c, u] of Object.entries(s)) {
    const h = Object.keys(u).length;
    if (h == 0) continue;
    const f = a(u, n), [r, l] = Object.entries(u)[0];
    if (h === 1)
      o[r] = { edge: l, pointInGroup: 0, groupWidth: 0 }, i[c] = { edges: u, groupWidth: 0, summarize: !1 };
    else {
      let d = 0;
      const b = Object.entries(u).map(([v, w]) => {
        let E = _.value(n.edge.normal.width, w);
        return isNaN(+E) && (console.warn(
          "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
          v,
          E
        ), E = 1), E / 2;
      }), k = Object.entries(u).map(([v, w], E) => (E > 0 && (d += b[E - 1] + f + b[E]), [v, w, d])), g = d;
      k.forEach(([v, w, E]) => {
        o[v] = { edge: w, pointInGroup: E, groupWidth: g };
      }), i[c] = { edges: u, groupWidth: g, summarize: !1 };
    }
  }
  return { edgeLayoutPoints: o, edgeGroups: i };
}
function un(n, e, t, o) {
  if (Object.entries(e).length === 1) return !1;
  const s = Math.min(
    ...Object.values(e).flatMap((a) => [n[a.source], n[a.target]]).filter((a) => a).map((a) => {
      const c = _.values(t.node.normal, a);
      return c.type === "circle" ? c.radius * 2 : Math.min(c.width, c.height);
    })
  );
  return o > s;
}
function dn(n, e, t, o, i, s, a) {
  var r, l, d, b, k, g, v, w;
  let c, u, h, f;
  return n.source < n.target ? [c, u, h, f] = fn(
    (r = e == null ? void 0 : e.x) != null ? r : 0,
    (l = e == null ? void 0 : e.y) != null ? l : 0,
    (d = t == null ? void 0 : t.x) != null ? d : 0,
    (b = t == null ? void 0 : t.y) != null ? b : 0,
    o,
    i,
    s,
    a
  ) : [h, f, c, u] = fn(
    (k = t == null ? void 0 : t.x) != null ? k : 0,
    (g = t == null ? void 0 : t.y) != null ? g : 0,
    (v = e == null ? void 0 : e.x) != null ? v : 0,
    (w = e == null ? void 0 : e.y) != null ? w : 0,
    o,
    i,
    s,
    a
  ), { p1: { x: c, y: u }, p2: { x: h, y: f } };
}
function fn(n, e, t, o, i, s, a, c) {
  const u = t - n, h = o - e;
  let f = (s / 2 - a) * i;
  if (f !== 0 && c !== "clock") {
    const r = Math.atan2(o - e, t - n);
    if (c === "vertical") {
      const l = Math.PI / 2;
      (r < -l || r >= l) && (f *= -1);
    } else c === "horizontal" && r < 0 && (f *= -1);
  }
  if (u === 0) {
    const r = h < 0 ? -1 : 1;
    return [n + f * r, e, t + f * r, o];
  } else if (h === 0) {
    const r = u < 0 ? 1 : -1;
    return [n, e + f * r, t, o + f * r];
  } else {
    const l = -1 / (h / u);
    h < 0 && (f = -f);
    const d = f / Math.sqrt(1 + Math.pow(l, 2));
    return [n + d, e + d * l, t + d, o + d * l];
  }
}
function jn(n, e, t) {
  return t || (t = { x: 0, y: 0 }), t.x = n.x + e.x, t.y = n.y + e.y, t;
}
function jt(n, e, t) {
  return t || (t = { x: 0, y: 0 }), t.x = n.x - e.x, t.y = n.y - e.y, t;
}
function Bn(n, e, t) {
  return t || (t = { x: 0, y: 0 }), t.x = n.x * e.x, t.y = n.y * e.y, t;
}
function Rn(n, e, t) {
  return t || (t = { x: 0, y: 0 }), t.x = n.x * e, t.y = n.y * e, t;
}
function Bt(n, e, t) {
  return t || (t = { x: 0, y: 0 }), t.x = n.x / e.x, t.y = n.y / e.y, t;
}
function Vn(n, e) {
  return n.x * e.x + n.y * e.y;
}
function Wn(n, e) {
  return n.x * e.y - n.y * e.x;
}
function Rt(n) {
  return n.x * n.x + n.y * n.y;
}
function Vt(n) {
  return Math.sqrt(Rt(n));
}
function Wt(n, e) {
  const t = n.x - e.x, o = n.y - e.y;
  return t * t + o * o;
}
function Hn(n, e) {
  return Math.sqrt(Wt(n, e));
}
function Un(n, e) {
  e || (e = { x: 0, y: 0 });
  const t = Vt(n);
  return t === 0 ? (e.x = 1, e.y = 0) : Bt(n, { x: t, y: t }, e), e;
}
function nt(n, e, t) {
  t || (t = { x: 0, y: 0 });
  const o = n.x * Math.cos(e) - n.y * Math.sin(e), i = n.x * Math.sin(e) + n.y * Math.cos(e);
  return t.x = o, t.y = i, t;
}
const oi = 180 / Math.PI;
function ii(n) {
  return n * oi;
}
function Ht(n) {
  return Math.atan2(n.y, n.x);
}
function Ut(n) {
  return ii(Ht(n));
}
const si = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: jn,
  angle: Ht,
  angleDegree: Ut,
  cross: Wn,
  distance: Hn,
  distanceSquared: Wt,
  divide: Bt,
  dot: Vn,
  length: Vt,
  lengthSquared: Rt,
  multiply: Bn,
  multiplyScalar: Rn,
  normalize: Un,
  rotate: nt,
  subtract: jt
}, Symbol.toStringTag, { value: "Module" }));
class R {
  static fromArray(e) {
    return new R(e[0] || 0, e[1] || 0);
  }
  static fromObject(e) {
    return new R(e.x, e.y);
  }
  constructor(e, t) {
    this.x = e, this.y = t;
  }
  // instance methods
  add(e) {
    return jn(this, e, this);
  }
  subtract(e) {
    return jt(this, e, this);
  }
  multiply(e) {
    return Bn(this, e, this);
  }
  multiplyScalar(e) {
    return Rn(this, e, this);
  }
  divide(e) {
    return Bt(this, e, this);
  }
  dot(e) {
    return Vn(this, e);
  }
  cross(e) {
    return Wn(this, e);
  }
  lengthSquared() {
    return Rt(this);
  }
  length() {
    return Vt(this);
  }
  distanceSquared(e) {
    return Wt(this, e);
  }
  distance(e) {
    return Hn(this, e);
  }
  normalize() {
    return Un(this, this);
  }
  angle() {
    return Ht(this);
  }
  angleDegree() {
    return Ut(this);
  }
  rotate(e) {
    return nt(this, e, this);
  }
  isEqualTo(e) {
    return this.x === e.x && this.y === e.y;
  }
  clone() {
    return new R(this.x, this.y);
  }
  toObject() {
    return { x: this.x, y: this.y };
  }
  toArray() {
    return [this.x, this.y];
  }
}
const J = oe({
  Vector2D: R
}, si);
class Y {
  constructor(e, t, o) {
    this.source = e, this.target = t, this.v = o;
  }
  static fromLinePosition(e) {
    const t = R.fromObject(e.p1), o = R.fromObject(e.p2);
    return new Y(t, o, De(t, o));
  }
  static fromPositions(e, t) {
    const o = R.fromObject(e), i = R.fromObject(t);
    return new Y(o, i, De(o, i));
  }
  static fromVectors(e, t) {
    return new Y(e, t, De(e, t));
  }
}
function De(n, e) {
  return e.clone().subtract(n);
}
function ri(n) {
  return [R.fromObject(n.p1), R.fromObject(n.p2)];
}
function ai(n) {
  return new R((n.p1.x + n.p2.x) / 2, (n.p1.y + n.p2.y) / 2);
}
function ot(n, e) {
  return { p1: n, p2: e };
}
function Tt(n, e, t) {
  const o = Y.fromLinePosition(n);
  return li(o, e, t);
}
function li(n, e, t) {
  const o = n.v.clone().normalize(), i = n.source.clone().add(o.clone().multiplyScalar(e)), s = n.target.clone().subtract(o.clone().multiplyScalar(t));
  let a = i.toObject(), c = s.toObject();
  const u = De(i, s);
  if (n.v.angle() * u.angle() < 0) {
    const h = new R((a.x + c.x) / 2, (a.y + c.y) / 2), f = h.clone().add(o.multiplyScalar(0.5));
    a = h.toObject(), c = f.toObject();
  }
  return { p1: a, p2: c };
}
function ci(n) {
  return { p1: n.p2, p2: n.p1 };
}
function Ve(n) {
  const e = n.v.clone().normalize().rotate(Math.PI / 2);
  return Y.fromVectors(n.target, n.target.clone().add(e));
}
function Ft(n, e) {
  const t = e.v.clone().normalize(), o = e.source, i = J.subtract(n, o), s = t.dot(i);
  return o.clone().add(t.multiplyScalar(s));
}
function ut(n, e, t, o) {
  if (!(J.lengthSquared(J.subtract(e, t)) - o * o <= Math.pow(1, -10))) return null;
  const a = Y.fromVectors(n, e), c = Ft(t, a), u = J.length(J.subtract(c, t));
  if (o < u) return null;
  if (o === u) return c;
  const h = Math.sqrt(ie(o, 2) - ie(u, 2)), f = a.v.normalize().multiplyScalar(h);
  return c.subtract(f);
}
function ui(n, e, t, o, i) {
  if (!(J.lengthSquared(J.subtract(e, t)) - o * o <= Math.pow(1, -10))) return null;
  const c = Y.fromVectors(n, e), u = Ft(t, c), h = J.length(J.subtract(u, t));
  if (o < h) return null;
  if (o === h) return u;
  const f = Math.sqrt(ie(o, 2) - ie(h, 2)), r = c.v.normalize().multiplyScalar(f), l = u.clone().add(r), d = u.clone().subtract(r), b = i.distance(l), k = i.distance(d);
  return Math.abs(b - k) < 2 ? d : b < k ? l : d;
}
function _e(n, e) {
  const t = J.subtract(e.source, n.source), o = n.v, i = e.v, s = J.cross(t, o) / J.cross(o, i);
  return e.source.clone().add(i.clone().multiplyScalar(s));
}
function qe(n, e, t, o, i) {
  const s = n, c = t.clone().subtract(s), u = c.length(), h = e + o;
  if (h < u) return null;
  const f = Math.abs(e - o);
  if (u < f) return null;
  if (u === h) {
    const y = c.clone().normalize(), x = n.clone().add(y.multiplyScalar(e));
    return i ? x : [x, x];
  }
  if (u === f) {
    const y = c.clone().normalize(), x = e > o, z = n.clone().add(y.multiplyScalar(x ? e : -e));
    return i ? z : [z, z];
  }
  const r = e, l = o, d = (ie(u, 2) + ie(r, 2) - ie(l, 2)) / (2 * u * r), b = r * d, k = Math.sqrt(ie(r, 2) - ie(b, 2)), g = c.clone().normalize(), v = new R(-g.y, g.x), w = g.clone().multiplyScalar(b), E = v.clone().multiplyScalar(k), m = n.clone().add(w).add(E), p = n.clone().add(w).subtract(E);
  if (i) {
    const y = m.distance(i), x = p.distance(i);
    return y < x ? m : p;
  } else
    return [m, p];
}
function hn(n, e, t, o) {
  const i = Y.fromPositions(n, e), s = (t.width + t.strokeWidth) / 2 * o, a = (t.height + t.strokeWidth) / 2 * o, c = t.borderRadius > 0 ? (t.borderRadius + t.strokeWidth / 2) * o : 0, u = (i.v.angle() - Math.PI / 2) % Math.PI, h = Math.PI / 2 - u % Math.PI, f = a * Math.abs(Math.tan(u)), r = s * Math.abs(Math.tan(h)), l = f <= s - c, d = r <= a - c;
  if (l || d || c === 0)
    return Math.sqrt(l ? ie(a, 2) + ie(f, 2) : ie(s, 2) + ie(r, 2));
  {
    const b = e.x - s + c, k = e.y - a + c, g = e.x + s - c, v = e.y + a - c, w = [
      new R(b, k),
      new R(g, k),
      new R(g, v),
      new R(b, v)
    ], E = Math.floor((i.v.angleDegree() + 360) % 360 / 90), m = w[E], p = ut(
      i.source,
      Ft(m, i),
      m,
      c
    );
    return p ? De(p, i.target).length() : De(m, i.target).length() + c;
  }
}
function Fn(n, e, t, o, i) {
  const s = Y.fromLinePosition(n), a = s.v.clone().normalize(), c = o === 0 ? s.source : s.source.clone().add(a.clone().multiplyScalar(o * i)), u = o === 0 ? s.target : s.target.clone().subtract(a.clone().multiplyScalar(o * i)), h = (e.width / 2 + t) * i, f = new R(-a.y, a.x).multiplyScalar(h);
  let r = J.subtract(c, f), l = J.add(c, f), d = J.subtract(u, f), b = J.add(u, f);
  const k = s.v.angleDegree();
  return (k < -90 || k >= 90) && ([r, l] = [l, r], [d, b] = [b, d]), {
    source: { above: r, below: l },
    target: { above: d, below: b }
  };
}
function di(n, e, t, o) {
  let i;
  t.type === "circle" ? i = t.radius + t.strokeWidth / 2 : i = hn(
    e,
    n,
    t,
    1
    // scale
  );
  let s;
  return o.type === "circle" ? s = o.radius + o.strokeWidth / 2 : s = hn(
    n,
    e,
    o,
    1
    // scale
  ), [i, s];
}
function Se(n, e, t) {
  const { x: o, y: i } = n, s = o - e.x, a = i - e.y;
  return {
    x: s * Math.cos(t) - a * Math.sin(t) + e.x,
    y: s * Math.sin(t) + a * Math.cos(t) + e.y
  };
}
function _t(n) {
  return n > 0 ? -(Math.PI * 2 - n) : Math.PI * 2 + n;
}
function It(n, e, t, o) {
  const i = [], s = Y.fromVectors(e, n), a = Y.fromVectors(e, t);
  let c = Ne(s, a);
  o * c < 0 && (c = _t(c));
  const u = R.fromObject(Se(n, e, -c / 2)), h = Y.fromVectors(e, u), f = Ve(h), r = Ne(s, h);
  let l = Ve(s);
  if (Math.abs(r) < Math.PI / 2) {
    const b = _e(l, f);
    i.push(b);
  } else {
    const b = R.fromObject(Se(u, e, r / 2)), k = Ve(
      Y.fromVectors(e, R.fromObject(b))
    ), g = _e(l, k), v = _e(k, f);
    i.push(g, b, v);
  }
  i.push(u);
  const d = Ne(a, h);
  if (l = Ve(a), Math.abs(d) < Math.PI / 2) {
    const b = _e(l, f);
    i.push(b);
  } else {
    const b = R.fromObject(Se(u, e, d / 2)), k = Ve(
      Y.fromVectors(e, R.fromObject(b))
    ), g = _e(f, k), v = _e(k, l);
    i.push(g, b, v);
  }
  return i;
}
function Ne(n, e) {
  return Math.atan2(
    n.v.y * e.v.x - n.v.x * e.v.y,
    n.v.x * e.v.x + n.v.y * e.v.y
  );
}
function fi(n, e, t) {
  const o = n.x, i = n.y, s = e.x, a = e.y, c = t.x, u = t.y, h = o - s, f = i - a, r = c - s, l = u - a;
  if (h === 0 && f === 0 || r === 0 && l === 0)
    return [n, 0];
  const d = (l * (h * (o + s) + f * (i + a)) - f * (r * (c + s) + l * (u + a))) / (2 * h * l - 2 * f * r), b = (-r * (h * (o + s) + f * (i + a)) + h * (r * (c + s) + l * (u + a))) / (2 * h * l - 2 * f * r), k = Math.sqrt(Math.pow(o - d, 2) + Math.pow(i - b, 2));
  return [new R(d, b), k];
}
function Ze(n) {
  return n.type == "circle" ? n.radius : Math.min(n.width, n.height) / 2;
}
function hi(n) {
  const e = Object.values(n);
  if (e.length === 0)
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    };
  const t = {
    top: e[0].y,
    bottom: e[0].y,
    left: e[0].x,
    right: e[0].x
  };
  return e.forEach((o) => {
    t.top = Math.min(o.y, t.top), t.bottom = Math.max(o.y, t.bottom), t.left = Math.min(o.x, t.left), t.right = Math.max(o.x, t.right);
  }), t;
}
function Qe(...n) {
  return n.find((e) => !!e);
}
const pi = Number.EPSILON * 100;
function vi(n, e, t, o, i, s, a, c) {
  var k, g;
  const u = n.edges, h = n.directions, f = u.map((v, w) => mi(v, h[w], o[v.edgeId])), r = [];
  let l = !1, d = !1;
  {
    const v = f[0];
    let w = Ze(e[v.source].shape) * i;
    const E = c + (a === "edgeOfNode" ? w : 0), m = E <= 0 ? v.line.source : vn(v, E, t, !0);
    r.push(m), w = Ze(e[v.target].shape) * i, c > 0 && J.distance(v.line.source, v.line.target) <= E + w && (l = !0);
  }
  const b = u.length;
  for (let v = 1; v < b; v++) {
    const w = f[v - 1], E = f[v], m = E.source, p = R.fromObject((k = t[m]) != null ? k : { x: 0, y: 0 }), y = gi(w, E, p), x = Ze(e[m].shape) * i, z = Math.max(x * (2 / 3), x - 4 * i), L = Lt(w), C = Lt(E), T = Je(w, p, z, L), $ = Je(E, p, z, !C), N = Je(w, p, x, L), G = Je(E, p, x, !C);
    let B;
    if (y) {
      const H = J.distance(y, p);
      if (H < z)
        B = [
          Qe(T, N, w.line.target),
          y,
          Qe($, G, E.line.source)
        ];
      else if (H <= x) {
        let fe, se;
        N && T ? fe = J.distance(y, T) < J.distance(y, N) ? T : N : fe = N || w.line.target, G && $ ? se = J.distance(y, $) < J.distance(y, G) ? $ : G : se = G || E.line.source, B = [fe, y, se];
      } else
        T && $ ? B = [T, p, $] : N && G ? B = [N, p, G] : B = [
          Qe(T, N, w.line.target),
          p,
          Qe($, G, E.line.source)
        ];
    } else
      T && $ ? B = [T, p, $] : N && G ? B = [N, p, G] : B = [w.line.target, p, E.line.source];
    if (w.curve) {
      const H = r[r.length - 1];
      if (H) {
        const fe = H instanceof Array ? H[H.length - 1] : H;
        let se;
        B instanceof Array ? se = s ? B[0] : B[1] : se = B;
        const ge = It(
          fe,
          w.curve.circle.center,
          se,
          w.curve.theta
        );
        B instanceof Array && s ? r.push([...ge, ...B]) : r.push([...ge, se]);
      }
    } else if (w.loop) {
      const [H, fe, se] = mn(p, w, x);
      r.push(H), r.push(se), B instanceof Array && s ? r.push([fe, B[1], B[2]]) : r.push(B[2]);
    } else
      s || !(B instanceof Array) ? r.push(B) : E.curve ? r.push(B[1]) : E.loop ? r.push(B[0]) : r.push(B[0], B[2]);
  }
  {
    const v = f[f.length - 1];
    let w = Ze(e[v.target].shape) * i;
    const E = c + (a === "edgeOfNode" ? w : 0), m = E <= 0 ? v.line.target : vn(v, E, t, !1);
    if (w = Ze(e[v.source].shape) * i, v.loop) {
      const p = R.fromObject((g = t[v.target]) != null ? g : { x: 0, y: 0 }), [y, x, z] = mn(p, v, w);
      r.push(y), r.push(z);
    } else if (v.curve) {
      const p = r[r.length - 1], y = p instanceof Array ? p[p.length - 1] : p, x = It(
        y,
        v.curve.circle.center,
        m,
        v.curve.theta
      );
      r.push([...x, m]);
    } else
      r.push(m);
    c > 0 && J.distance(v.line.source, v.line.target) <= E + w && (d = !0);
  }
  return l && (r.shift(), r[0] instanceof Array && r.unshift(r[0][0])), d && r.pop(), r;
}
function pn(n) {
  const e = n.length;
  if (e === 0) return [];
  if (e <= 1) return [!0];
  const t = [];
  let o = null, i = !0;
  for (let s = 0; s < e; s++) {
    const a = n[s].edge.source, c = n[s].edge.target;
    if (s === 0)
      if (e > 2) {
        const u = qn(n, 0);
        u === null ? i = !0 : i = u === c;
      } else
        i = [n[1].edge.source, n[1].edge.target].includes(c);
    else a === c ? i = !0 : i = o === a;
    t.push(i), o = i ? c : a;
  }
  return t;
}
function qn(n, e) {
  const t = n[e], o = n[e + 1], i = [t.edge.source, t.edge.target].sort(), s = [o.edge.source, o.edge.target].sort();
  if (i[0] === i[1])
    return i[0];
  if (s[0] === s[1])
    return s[0];
  if (t.edgeId === o.edgeId || i[0] === s[0] && i[1] === s[1]) {
    if (e >= n.length - 2)
      return null;
    {
      const a = qn(n, e + 1);
      return a === null ? null : a === i[1] ? i[0] : i[1];
    }
  } else
    return s.includes(i[1]) ? i[1] : i[0];
}
function vn(n, e, t, o) {
  const i = o ? n.source : n.target, s = n.curve;
  if (s) {
    let a = e / s.circle.radius;
    return s.theta > 0 && (a *= -1), o || (a *= -1), R.fromObject(
      Se(
        o ? n.line.source : n.line.target,
        s.circle.center,
        a
      )
    );
  } else {
    let a, c;
    if (o ? (a = n.line.target, c = n.line.source) : (a = n.line.source, c = n.line.target), t[i]) {
      const u = ut(
        a,
        c,
        R.fromObject(t[i]),
        e
      );
      return u === null ? a : u;
    } else
      return a;
  }
}
function gi(n, e, t) {
  let o = null;
  if (n.loop || e.loop)
    o = null;
  else if (n.curve)
    if (e.curve) {
      if (n.line.target.isEqualTo(e.line.source))
        return n.line.target.clone();
      o = qe(
        n.curve.circle.center,
        n.curve.circle.radius,
        e.curve.circle.center,
        e.curve.circle.radius,
        n.curve.center
      );
    } else
      o = ui(
        e.line.target,
        e.line.source,
        n.curve.circle.center,
        n.curve.circle.radius,
        t
      );
  else if (e.curve)
    o = ut(
      n.line.source,
      n.line.target,
      e.curve.circle.center,
      e.curve.circle.radius
    );
  else {
    const i = gn(n.line), s = gn(e.line);
    !isFinite(i) && !isFinite(s) || Math.abs(i - s) < pi ? o = null : o = _e(n.line, e.line);
  }
  return o;
}
function Je(n, e, t, o) {
  if (n.loop) {
    const i = qe(
      e,
      t,
      n.loop.center,
      n.loop.radius[0]
    );
    return i ? o ? i[0] : i[1] : null;
  } else return n.curve ? qe(
    e,
    t,
    n.curve.circle.center,
    n.curve.circle.radius,
    R.fromObject(n.curve.center)
  ) : ut(
    o ? n.line.source : n.line.target,
    o ? n.line.target : n.line.source,
    e,
    t
  );
}
function mi(n, e, t) {
  let o = t.origin, i = n.edge.source, s = n.edge.target, a = t.curve;
  const c = t.loop;
  c ? o = t.position : e || (o = ci(o), i = n.edge.target, s = n.edge.source, a && (a = Be(oe({}, a), { theta: -a.theta })));
  const u = Y.fromLinePosition(o);
  return {
    edgeId: n.edgeId,
    source: i,
    target: s,
    line: u,
    direction: e,
    curve: a,
    loop: c
  };
}
function gn(n) {
  return (n.target.y - n.source.y) / (n.target.x - n.source.x);
}
function mn(n, e, t) {
  const { radius: o, center: i } = q(e.loop, "Loop of edge parameter"), [s, a] = o, c = qe(n, t, i, o[0]);
  let [u, h] = c ? c.reverse() : [e.line.source, e.line.target];
  const f = Lt(e);
  f || ([u, h] = [h, u]);
  const r = u, l = h, d = R.fromObject(r).subtract(i).angleDegree();
  let g = (R.fromObject(l).subtract(i).angleDegree() + 360 - d) % 360 >= 180;
  return g = f ? g : !g, [r, l, `A ${s} ${a} 0 ${g ? 1 : 0} ${f ? 1 : 0} ${l.x} ${l.y}`];
}
function Lt(n) {
  return n.loop ? n.direction ? n.loop.isClockwise : !n.loop.isClockwise : !0;
}
function yt(n, e, t, o, i, s, a) {
  const c = Ee({});
  F(
    () => new Set(Object.keys(n.value)),
    (h, f) => {
      f || (f = /* @__PURE__ */ new Set([]));
      for (const r of h)
        f.has(r) || bi(n, c, r, !1, e, i);
      for (const r of f)
        h.has(r) || (t.delete(r), o.delete(r), s == null || s(r, c[r]), delete c[r]);
    },
    { immediate: !0 }
  ), F(
    () => [...t],
    (h, f) => {
      const r = f ? h.filter((d) => !f.includes(d)) : h, l = f ? f.filter((d) => !h.includes(d)) : [];
      r.forEach((d) => {
        const b = c[d];
        b && !b.selected && (b.selected = !0);
      }), l.forEach((d) => {
        const b = c[d];
        b && b.selected && (b.selected = !1);
      });
    },
    { immediate: !0 }
    // for specified from the beginning
  ), F(
    () => [...o],
    (h, f) => {
      const r = h.filter((d) => !f.includes(d)), l = f.filter((d) => !h.includes(d));
      r.forEach((d) => {
        const b = c[d];
        b && !b.hovered && (b.hovered = !0);
      }), l.forEach((d) => {
        const b = c[d];
        b && b.hovered && (b.hovered = !1);
      });
    }
  );
  const u = O(() => {
    const h = a ? a() : Object.values(c);
    return e.zOrder.enabled ? yi(h, e.zOrder, o, t) : h;
  });
  return { states: c, zOrderedList: u };
}
function bi(n, e, t, o, i, s) {
  const a = {
    id: t,
    selected: o,
    hovered: !1,
    selectable: O(() => n.value[t] ? _.value(i.selectable, n.value[t]) : M(a.selectable)),
    zIndex: O(() => n.value[t] ? _.value(i.zOrder.zIndex, n.value[t]) : M(a.zIndex))
  };
  e[t] = a, s(
    n,
    t,
    e[t]
    /* get reactive object */
  );
}
function yi(n, e, t, o) {
  return e.bringToFrontOnHover && e.bringToFrontOnSelected ? n.sort((i, s) => {
    const a = t.has(i.id), c = t.has(s.id);
    if (a != c)
      return a ? 1 : -1;
    const u = o.has(i.id), h = o.has(s.id);
    return u != h ? u ? 1 : -1 : i.zIndex - s.zIndex;
  }) : e.bringToFrontOnHover ? n.sort((i, s) => {
    const a = t.has(i.id), c = t.has(s.id);
    return a != c ? a ? 1 : -1 : i.zIndex - s.zIndex;
  }) : e.bringToFrontOnSelected ? n.sort((i, s) => {
    const a = o.has(i.id), c = o.has(s.id);
    return a != c ? a ? 1 : -1 : i.zIndex - s.zIndex;
  }) : n.sort((i, s) => i.zIndex - s.zIndex);
}
function wi(n) {
  return typeof btoa === void 0 ? Buffer.from(n).toString("base64").replaceAll("=", "") : btoa(n).replaceAll("=", "");
}
function Ei() {
  return { markers: Ee({}), referenceCount: {} };
}
function ki(n) {
  const { markers: e, referenceCount: t } = n;
  function o(c, u) {
    var f;
    const h = (f = t[c]) != null ? f : 0;
    t[c] = h + 1, h || (e[c] = u);
  }
  function i(c) {
    var h;
    const u = (h = t[c]) != null ? h : 0;
    u && (u - 1 === 0 ? (delete e[c], delete t[c]) : t[c] = u - 1);
  }
  function s(c) {
    c && i(c);
  }
  function a(c, u, h, f, r) {
    if (c.type === "none") {
      s(h);
      return;
    }
    if (c.type === "custom")
      return s(h), c.customId;
    const l = xi(c, u, f), d = Pi(l, r);
    return d === h || (s(h), o(d, l)), d;
  }
  return {
    makeMarker: a,
    clearMarker: s
  };
}
function xi(n, e, t) {
  var o;
  return Be(oe({}, n), {
    color: (o = n.color) != null ? o : t,
    isSource: e
  });
}
function Pi(n, e) {
  const t = wi(n.color), o = n.isSource ? "L" : "R", i = n.units === "strokeWidth" ? "rel" : "abs";
  return `marker_${e}_${n.type}_${n.width}_${n.height}_${n.margin}_${n.offset}_${t}_${o}_${i}`;
}
function wt(n, e, t) {
  return {
    objects: n,
    selected: e,
    hovered: t
  };
}
const Xn = Symbol("states"), Si = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  offset: 0,
  units: "strokeWidth",
  color: null
};
function Mi(n, e, t, o, i, s, a, c) {
  const u = Ee({}), h = xe({});
  ue(() => {
    const m = Object.fromEntries(
      Object.keys(n.objects.value).map((p) => [p, {}])
    );
    Object.entries(e.objects.value).forEach(([p, y]) => {
      m != null && m[y.source] || (m[y.source] = {}), m != null && m[y.target] || (m[y.target] = {}), m[y.source][p] = y.target, m[y.target][p] = y.source;
    }), et(h, m);
  });
  const {
    states: f,
    zOrderedList: r
    //
  } = yt(
    n.objects,
    o.node,
    n.selected,
    n.hovered,
    (m, p, y) => {
      zi(
        m,
        p,
        y,
        o.node,
        h,
        i,
        s
      );
    },
    (m, p) => {
      const y = i.nodes;
      delete y[m];
    }
  ), l = Qo(), d = ei(n.objects, e.objects, o), b = j([]), {
    states: k,
    zOrderedList: g
    //
  } = yt(
    e.objects,
    o.edge,
    e.selected,
    e.hovered,
    (m, p, y) => {
      _i(
        m,
        p,
        y,
        o.edge,
        a,
        f,
        d,
        i,
        c,
        l
      );
    },
    (m, p) => {
      var y;
      (y = p.stopWatchHandle) == null || y.call(p);
    },
    () => b.value
  );
  ue(() => {
    b.value = Ii(d.edgeGroups, k);
  }), F(
    d.edgeGroups,
    (m) => Ai(u, d, o),
    { immediate: !0 }
  );
  const {
    states: v,
    zOrderedList: w
    //
  } = yt(
    t.objects,
    o.path,
    t.selected,
    t.hovered,
    (m, p, y) => {
      const x = y;
      x.clickable = O(() => m.value[p] ? _.value(o.path.clickable, m.value[p]) : !1), x.hoverable = O(() => m.value[p] ? _.value(o.path.hoverable, m.value[p]) : !1), x.path = m.value[p], x.edges = yn(x.path, e), x.directions = pn(x.edges), x.stopWatchHandle = F(
        () => m.value[p].edges,
        () => {
          x.path = m.value[p], x.edges = yn(x.path, e), x.directions = pn(x.edges);
        }
      );
    },
    (m, p) => {
      var y;
      (y = p.stopWatchHandle) == null || y.call(p);
    }
  ), E = {
    nodeStates: f,
    edgeStates: k,
    edgeGroupStates: d,
    summarizedEdgeStates: u,
    pathStates: v,
    layouts: i,
    nodeZOrderedList: r,
    edgeZOrderedList: g,
    pathZOrderedList: w
  };
  return Me(Xn, E), E;
}
function Ci(n) {
  return n.summarized;
}
function me() {
  return q(Ce(Xn), "states");
}
function Oi(n, e, t, o) {
  return t && o.hover ? _.values(o.hover, n) : Gn(n, e, o);
}
function Gn(n, e, t) {
  return e && t.selected ? _.values(t.selected, n) : _.values(t.normal, n);
}
function zi(n, e, t, o, i, s, a) {
  var c, u;
  !s.nodes[e] && ((c = a.nodes) != null && c[e]) && (s.nodes[e] = oe({}, (u = a.nodes) == null ? void 0 : u[e])), t.shape = O(() => n.value[e] ? Oi(n.value[e], t.selected, t.hovered, o) : M(t.shape)), t.staticShape = O(() => n.value[e] ? Gn(n.value[e], t.selected, o) : M(t.staticShape)), t.label = O(() => n.value[e] ? _.values(o.label, n.value[e]) : M(t.label)), t.labelText = O(() => {
    var h, f;
    return o.label.text instanceof Function ? M(t.label).text : n.value[e] ? (f = (h = n.value[e]) == null ? void 0 : h[M(t.label).text]) != null ? f : "" : M(t.labelText);
  }), t.draggable = O(() => n.value[e] ? _.value(o.draggable, n.value[e]) : M(t.draggable)), t.oppositeNodeIds = we(i, e), t.oppositeNodes = O(() => Object.entries(t.oppositeNodeIds).reduce(
    (h, f) => {
      const [r, l] = f, d = s.nodes[l];
      return d && (h[r] = { nodeId: l, pos: oe({}, d) }), h;
    },
    {}
  ));
}
function Ti(n, e, t, o) {
  return e ? _.values(o.selected, n) : t && o.hover ? _.values(o.hover, n) : _.values(o.normal, n);
}
function bn(n) {
  return n.type === "none" ? Si : n;
}
function _i(n, e, t, o, i, s, a, c, u, h) {
  const { makeMarker: f, clearMarker: r } = ki(i);
  Object.assign(t, {
    origin: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    labelPosition: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } },
    position: { p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }
  }), t.label = O(() => n.value[e] ? _.values(o.label, n.value[e]) : M(t.label));
  const l = O(() => {
    const v = n.value[e], w = Ti(v, t.selected, t.hovered, o);
    isNaN(+w.width) && (console.warn(
      "[v-network-graph] Edge width is invalid value. id=[%s] value=[%s]",
      e,
      w.width
    ), w.width = 1), (w.color === void 0 || w.color === null) && (console.warn(
      "[v-network-graph] Edge color is invalid value. id=[%s] value=[%s]",
      e,
      w.color
    ), w.color = "#000000");
    let E = _.value(o.normal.width, v);
    isNaN(+E) && (E = 1);
    const m = bn(_.values(o.marker.source, [v, w])), p = bn(_.values(o.marker.target, [v, w]));
    return { stroke: w, normalWidth: E, source: m, target: p };
  });
  t.line = l;
  const d = we(
    a.edgeLayoutPoints,
    e
  ), b = we(a.summarizedEdges, e), k = ue(() => {
    var B, H, fe, se, ge, Oe, ze;
    const v = n.value[e];
    if (!v) return;
    const w = (B = s[v.source]) == null ? void 0 : B.staticShape, E = (H = s[v.target]) == null ? void 0 : H.staticShape;
    if (!w || !E)
      return;
    const m = (fe = c.nodes[v == null ? void 0 : v.source]) != null ? fe : { x: 0, y: 0 }, p = (se = c.nodes[v == null ? void 0 : v.target]) != null ? se : { x: 0, y: 0 }, y = ti(
      d.value,
      (ge = b.value) != null ? ge : !1,
      m,
      p,
      u.value,
      o.keepOrder
    ), [x, z] = di(m, p, w, E), L = u.value;
    t.labelPosition = Tt(
      y,
      x * L,
      z * L
    );
    let C = 0, T = 0;
    const $ = l.value;
    if ($.source.type !== "none") {
      const re = $.source;
      C = re.margin + re.width, re.units === "strokeWidth" && (C *= $.normalWidth);
    }
    if ($.target.type !== "none") {
      const re = $.target;
      T = re.margin + re.width, re.units === "strokeWidth" && (T *= $.normalWidth);
    }
    o.margin && (C += o.margin, T += o.margin);
    const N = !!o.margin || $.source.type !== "none" || $.target.type !== "none";
    if (v.source === v.target) {
      t.origin = ot(m, p);
      const re = _.values(o.selfLoop, v), [Le, $e] = $i(
        m,
        w,
        re,
        N,
        C,
        T,
        (ze = (Oe = d.value) == null ? void 0 : Oe.pointInGroup) != null ? ze : 0,
        L
      );
      t.position = Le, t.loop = $e, t.curve = void 0;
      return;
    } else
      t.loop = void 0;
    if (N && (C += x, T += z), o.type === "straight" || b.value)
      t.origin = y, t.curve = void 0, C === 0 && T === 0 ? t.position = t.origin : t.position = Tt(t.origin, C * L, T * L);
    else {
      t.origin = ot(m, p);
      const re = d.value ? d.value.groupWidth / 2 - d.value.pointInGroup : 0, [Le, $e] = Li(
        t.origin,
        y,
        re,
        C * L,
        T * L
      );
      t.position = Le, t.curve = $e;
    }
  }), g = ue(() => {
    n.value[e] && (t.sourceMarkerId = f(
      l.value.source,
      !0,
      t.sourceMarkerId,
      l.value.stroke.color,
      h
    ), t.targetMarkerId = f(
      l.value.target,
      !1,
      t.targetMarkerId,
      l.value.stroke.color,
      h
    ));
  });
  t.stopWatchHandle = () => {
    k(), g(), r(t.sourceMarkerId), r(t.targetMarkerId);
  };
}
function Ii(n, e) {
  return Object.entries(n).map(([t, o]) => {
    var i;
    return o.summarize ? {
      id: (i = Object.keys(o.edges)[0]) != null ? i : t,
      summarized: !0,
      key: t,
      group: o,
      zIndex: Object.keys(o.edges).map((s) => {
        var a, c;
        return (c = (a = e[s]) == null ? void 0 : a.zIndex) != null ? c : 0;
      }).reduce((s, a) => Math.max(s, a))
    } : Object.entries(o.edges).map(
      ([s, a]) => {
        var c, u;
        return {
          id: s,
          summarized: !1,
          key: s,
          edge: a,
          zIndex: (u = (c = e[s]) == null ? void 0 : c.zIndex) != null ? u : 0
        };
      }
    );
  }).flat();
}
function Li(n, e, t, o, i) {
  const s = Y.fromLinePosition(n), a = Y.fromLinePosition(e), c = ai(e), [u, h] = fi(
    s.source,
    s.target,
    c
  );
  let f, r;
  if (h === 0)
    return [n, r];
  if (t === 0)
    return o === 0 && i === 0 ? f = n : f = Tt(n, o, i), [f, r];
  const l = Y.fromVectors(u, c), d = Ne(
    Y.fromVectors(u, s.source),
    l
  );
  if (o === 0 && i === 0)
    f = n;
  else {
    let v = o / h, w = i / h;
    d > 0 && (v *= -1, w *= -1), f = ot(
      Se(s.source, u, v),
      Se(s.target, u, -w)
    );
    let E = Ne(
      Y.fromVectors(u, s.source),
      Y.fromVectors(u, s.target)
    ), m = Ne(
      Y.fromPositions(u, f.p1),
      Y.fromPositions(u, f.p2)
    );
    if (d * E < 0 && (E = _t(E), d * m < 0 && (m = _t(m))), E * m < 0) {
      const p = c.clone().add(a.v.normalize().multiplyScalar(0.5));
      return f = ot(c, p), [f, r];
    }
  }
  const [b, k] = ri(f), g = It(b, u, k, d).map((v) => v.toObject());
  return r = {
    center: c,
    theta: d,
    circle: { center: u, radius: h },
    control: g
  }, [f, r];
}
function $i(n, e, t, o, i, s, a, c) {
  const u = c, h = (t.radius + a / 2) * u, f = t.offset * u + h, r = (t.angle - 90) * (Math.PI / 180), l = R.fromObject({
    x: n.x + f * Math.cos(r),
    y: n.y + f * Math.sin(r)
  }), d = t.isClockwise;
  let b, k;
  if (o) {
    const m = qe(
      l,
      h,
      R.fromObject(n),
      Ze(e) * u
    );
    if (m) {
      [b, k] = m;
      let p = 1;
      if (d || ([b, k] = [k, b], p = -1), i !== 0 || s !== 0) {
        const y = i * u / h * p, x = s * u / h * p;
        b = Se(b, l, y), k = Se(k, l, -x);
      }
    }
  }
  if (b === void 0 || k === void 0) {
    const m = R.fromObject(n).subtract(l).normalize().multiplyScalar(h);
    let p = 1 * (Math.PI / 180);
    d || (p *= -1), b = l.clone().add(nt(m, p)), k = l.clone().add(nt(m, -p));
  }
  const g = R.fromObject(b).subtract(l).angleDegree(), E = (R.fromObject(k).subtract(l).angleDegree() + 360 - g) % 360 >= 180;
  return [
    { p1: b, p2: k },
    {
      center: l,
      radius: [h, h],
      isLargeArc: d ? E : !E,
      isClockwise: d
    }
  ];
}
function Ai(n, e, t) {
  const o = e.edgeGroups;
  Object.entries(o).filter(([i, s]) => s.summarize && !(i in n)).forEach(([i, s]) => {
    const a = { stroke: void 0 };
    a.stroke = O(
      () => _.values(t.edge.summarized.stroke, s.edges)
    ), n[i] = a;
  }), Object.keys(n).forEach((i) => {
    var s;
    (s = e.edgeGroups[i]) != null && s.summarize || delete n[i];
  });
}
function yn(n, e) {
  return n.edges.map((t) => ({ edgeId: t, edge: e.objects.value[t] })).filter((t) => t.edge);
}
class Ue {
  static valueOf(e) {
    return Array.from(e.values());
  }
}
const Zi = 3, Di = 6, Kn = 500;
function tt(n) {
  return n === "touch" ? Di : Zi;
}
function qt(n, e, t, o) {
  let i = n.get(e);
  if (i)
    i.id !== t && (i = void 0);
  else {
    const c = Array.from(n.entries()).find(([u, h]) => h.id === t);
    if (c) {
      const [u, h] = c;
      n.delete(u), i = h;
    }
  }
  let s, a;
  return [i, s, a] = Yn(i, o, t), n.set(e, i), [s, a];
}
function Yn(n, e, t) {
  const o = Date.now();
  n && o - n.lastTime <= Kn ? (n.count++, n.lastTime = o) : n = { count: 1, lastTime: o, id: t };
  const i = {
    view: window,
    screenX: e.screenX,
    screenY: e.screenY,
    clientX: e.clientX,
    clientY: e.clientY,
    ctrlKey: e.ctrlKey,
    shiftKey: e.shiftKey,
    altKey: e.altKey,
    metaKey: e.metaKey,
    button: e.button,
    buttons: e.buttons,
    detail: n.count
  };
  let s, a;
  return e instanceof PointerEvent ? (Object.assign(i, {
    pointerId: e.pointerId,
    width: e.width,
    height: e.height,
    pressure: e.pressure,
    tangentialPressure: e.tangentialPressure,
    tiltX: e.tiltX,
    tiltY: e.tiltY,
    twist: e.twist,
    pointerType: e.pointerType,
    isPrimary: e.isPrimary
  }), s = new PointerEvent("click", i), n.count === 2 && (a = new PointerEvent("dblclick", i))) : (s = new MouseEvent("click", i), n.count === 2 && (a = new MouseEvent("dblclick", i))), [n, s, a];
}
function Xt(n) {
  const e = Date.now();
  Array.from(n.entries()).filter(([t, o]) => e - o.lastTime > Kn).map(([t, o]) => n.delete(t));
}
function Ni(n, e, t, o, i, s, a) {
  const c = {
    pointers: /* @__PURE__ */ new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodesPre: /* @__PURE__ */ new Set(),
    clicks: /* @__PURE__ */ new Map()
  }, u = {
    pointermove: d,
    pointerup: k,
    pointercancel: b
  };
  function h(m) {
    const p = c.follow.followedPointerId === m.pointerId, y = i.has(m.nodeId), x = !(m.pointerId in c.pointers);
    if (p && x || p && !y) {
      const z = Ue.valueOf(c.pointers).find((L) => i.has(L.nodeId));
      if (!z) {
        c.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      m = z, c.follow.followedPointerId = m.pointerId;
    } else {
      const z = c.pointers.get(c.follow.followedPointerId);
      if (!z) {
        c.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      m = z;
    }
    if (p || y) {
      const z = Ue.valueOf(c.pointers).map((L) => L.nodeId);
      c.follow.nodeBasePositions = Object.fromEntries(
        Array.from(i).filter((L) => !z.includes(L)).filter((L) => {
          var C;
          return (C = n[L]) == null ? void 0 : C.draggable;
        }).map((L) => [L, Et(e.nodes, L)])
      ), m.dragBasePosition = oe({}, m.latestPosition), m.nodeBasePosition = Et(e.nodes, m.nodeId);
    }
  }
  F(i, (m) => {
    const p = c.pointers.get(c.follow.followedPointerId);
    p && h(p), m.size > 0 && t.selectionMode.value !== "node" ? t.selectionMode.value = "node" : m.size === 0 && t.selectionMode.value === "node" && (t.selectionMode.value = "container");
  }), F(t.selectionMode, (m) => {
    m !== "node" && i.clear();
  });
  function f(m, p) {
    const y = m.dragBasePosition.x - p.pageX, x = m.dragBasePosition.y - p.pageY, z = c.follow.followedPointerId == m.pointerId ? oe({
      [m.nodeId]: m.nodeBasePosition
    }, c.follow.nodeBasePositions) : { [m.nodeId]: m.nodeBasePosition }, L = s.value;
    return Object.fromEntries(
      Object.entries(z).map(([C, T]) => [
        C,
        {
          x: T.x - y / L,
          y: T.y - x / L
        }
      ])
    );
  }
  function r(m, p) {
    var x, z;
    if (p.isTrusted || p.shiftKey && !["container", "node"].includes(t.selectionMode.value))
      return;
    t.selectionMode.value = "node";
    const y = (z = (x = n[m]) == null ? void 0 : x.selectable) != null ? z : !1;
    if (y) {
      const L = Ue.valueOf(c.pointers).filter((C) => i.has(C.nodeId)).length > 0;
      p.shiftKey || L ? i.has(m) ? i.delete(m) : typeof y == "number" && i.size >= y || i.add(m) : i.has(m) || (i.clear(), i.add(m));
    }
    a.emit("node:click", { node: m, event: p });
  }
  function l(m, p) {
    p.isTrusted || a.emit("node:dblclick", { node: m, event: p });
  }
  function d(m) {
    var z;
    m.stopPropagation();
    const p = c.pointers.get(m.pointerId);
    if (!p)
      return;
    p.latestPosition = { x: m.pageX, y: m.pageY }, p.moveCounter++;
    const y = tt(m.pointerType);
    if (p.moveCounter <= y || !((z = n[p.nodeId]) != null && z.draggable))
      return;
    if (p.moveCounter === y + 1) {
      const L = f(p, {
        pointerId: p.pointerId,
        pageX: p.dragBasePosition.x,
        pageY: p.dragBasePosition.y
      });
      a.emit("node:dragstart", L);
    }
    const x = f(p, m);
    a.emit("node:pointermove", x);
  }
  function b(m) {
    m.stopPropagation();
    let p = c.pointers.get(m.pointerId);
    if (p) {
      for (p of c.pointers.values()) {
        const y = p.nodeId, x = tt(m.pointerType);
        if (p.moveCounter > x) {
          const L = f(p, {
            pointerId: p.pointerId,
            pageX: p.latestPosition.x,
            pageY: p.latestPosition.y
          });
          a.emit("node:dragend", L);
        }
        a.emit("node:pointerup", { node: y, event: m });
      }
      c.pointers.clear(), c.follow = { followedPointerId: -1, nodeBasePositions: {} }, le(u).forEach(([y, x]) => {
        document.removeEventListener(y, x);
      }), t.viewMode.value = "default";
    }
  }
  function k(m) {
    var L, C, T;
    m.stopPropagation();
    const p = c.pointers.get(m.pointerId);
    if (!p)
      return;
    c.pointers.delete(m.pointerId);
    const y = p.nodeId, x = tt(m.pointerType), z = p.moveCounter > x;
    if (z) {
      if ((L = n[p.nodeId]) != null && L.draggable) {
        const $ = f(p, m);
        a.emit("node:dragend", $), a.emit("node:pointerup", { node: y, event: m });
      }
    } else
      a.emit("node:pointerup", { node: y, event: m });
    if (!z) {
      const [$, N] = qt(
        c.clicks,
        p.pointerId,
        y,
        m
      );
      (C = p.eventTarget) == null || C.dispatchEvent($), N && ((T = p.eventTarget) == null || T.dispatchEvent(N));
    }
    c.pointers.size === 0 ? (c.follow = { followedPointerId: -1, nodeBasePositions: {} }, le(u).forEach(([$, N]) => {
      document.removeEventListener($, N);
    }), Xt(c.clicks), t.viewMode.value = "default") : h(p), o.clear(), c.hoveredNodesPre.forEach(o.add, o);
  }
  function g(m, p) {
    if (p.button == 2 || (p.stopPropagation(), !["default", "node"].includes(t.viewMode.value)))
      return;
    c.pointers.size == 0 && (t.viewMode.value = "node", le(u).forEach(([x, z]) => {
      document.addEventListener(x, z);
    }));
    const y = {
      pointerId: p.pointerId,
      nodeId: m,
      moveCounter: 0,
      nodeBasePosition: Et(e.nodes, m),
      dragBasePosition: { x: p.pageX, y: p.pageY },
      latestPosition: { x: p.pageX, y: p.pageY },
      eventTarget: p.currentTarget
    };
    c.pointers.set(p.pointerId, y), i.has(m) && (c.follow.followedPointerId < 0 ? (c.follow.followedPointerId = p.pointerId, h(y)) : delete c.follow.nodeBasePositions[y.nodeId]), a.emit("node:pointerdown", { node: m, event: p });
  }
  function v(m, p) {
    c.hoveredNodesPre.add(m), !(c.pointers.size > 0) && (o.add(m), a.emit("node:pointerover", { node: m, event: p }));
  }
  function w(m, p) {
    c.hoveredNodesPre.delete(m), !(c.pointers.size > 0) && (o.delete(m), a.emit("node:pointerout", { node: m, event: p }));
  }
  function E(m, p) {
    p.stopPropagation(), a.emit("node:contextmenu", { node: m, event: p });
  }
  return {
    handleNodePointerDownEvent: g,
    handleNodePointerOverEvent: v,
    handleNodePointerOutEvent: w,
    handleNodeClickEvent: r,
    handleNodeDoubleClickEvent: l,
    handleNodeContextMenu: E
  };
}
function Et(n, e) {
  var o;
  const t = (o = n[e]) != null ? o : { x: 0, y: 0 };
  return oe({}, t);
}
function ji(n, e, t, o, i) {
  const s = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  }, a = {
    pointerup: u,
    pointercancel: h
  };
  F(o, (p) => {
    p.size > 0 && e.selectionMode.value !== "edge" ? e.selectionMode.value = "edge" : p.size === 0 && e.selectionMode.value === "edge" && (e.selectionMode.value = "container");
  }), F(e.selectionMode, (p) => {
    p !== "edge" && o.clear();
  });
  function c(p, y) {
    if (y.button == 2 || (y.stopPropagation(), !["default", "edge"].includes(e.viewMode.value)))
      return;
    s.pointers.size == 0 && (e.viewMode.value = "edge", le(a).forEach(([z, L]) => {
      document.addEventListener(z, L);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const x = {
      pointerId: y.pointerId,
      id: p,
      eventTarget: y.currentTarget
    };
    s.pointers.set(y.pointerId, x), i.emit("edge:pointerdown", he(p, y));
  }
  function u(p) {
    var C, T;
    p.stopPropagation();
    const y = s.pointers.get(p.pointerId);
    if (!y)
      return;
    s.pointers.delete(p.pointerId);
    const x = y.id;
    i.emit("edge:pointerup", he(x, p));
    const [z, L] = qt(
      s.clicks,
      y.pointerId,
      x instanceof Array ? x.join(",") : x,
      p
    );
    (C = y.eventTarget) == null || C.dispatchEvent(z), L && ((T = y.eventTarget) == null || T.dispatchEvent(L)), s.pointers.size === 0 && (s.pointerPeekCount = 0, le(a).forEach(([$, N]) => {
      document.removeEventListener($, N);
    }), Xt(s.clicks), e.viewMode.value = "default");
  }
  function h(p) {
    if (p.stopPropagation(), !!s.pointers.get(p.pointerId)) {
      for (const x of s.pointers.values()) {
        const z = x.id;
        i.emit("edge:pointerup", he(z, p));
      }
      s.pointers.clear(), s.pointerPeekCount = 0, le(a).forEach(([x, z]) => {
        document.removeEventListener(x, z);
      }), i.emit("view:mode", "default");
    }
  }
  function f(p, y) {
    var L;
    if (y.isTrusted || y.shiftKey && !["container", "edge"].includes(e.selectionMode.value))
      return;
    e.selectionMode.value = "edge";
    const x = p instanceof Array ? p : [p], z = Ue.valueOf(s.pointers).filter((C) => (C.id instanceof Array ? C.id : [C.id]).every(($) => o.has($))).length > 0;
    if (p instanceof Array)
      x.find((T) => {
        var $;
        return ($ = n[T]) == null ? void 0 : $.selectable;
      }) && (y.shiftKey || z ? x.some((T) => o.has(T)) ? x.forEach((T) => o.delete(T)) : x.forEach((T) => {
        var N;
        const $ = (N = n[T]) == null ? void 0 : N.selectable;
        typeof $ == "number" && o.size >= $ || o.add(T);
      }) : (o.clear(), x.forEach((T) => o.add(T))));
    else {
      const C = (L = n[p]) == null ? void 0 : L.selectable;
      C && (y.shiftKey || z ? o.has(p) ? o.delete(p) : typeof C == "number" && o.size >= C || o.add(p) : o.has(p) || (o.clear(), o.add(p)));
    }
    i.emit("edge:click", he(p, y));
  }
  function r(p, y) {
    y.isTrusted || i.emit("edge:dblclick", he(p, y));
  }
  function l(p, y) {
    t.add(p), i.emit("edge:pointerover", he(p, y));
  }
  function d(p, y) {
    t.delete(p), i.emit("edge:pointerout", he(p, y));
  }
  function b(p, y) {
    y.stopPropagation(), i.emit("edge:contextmenu", he(p, y));
  }
  function k(p, y) {
    if (y.button == 2 || (y.stopPropagation(), !["default", "edge"].includes(e.viewMode.value)))
      return;
    s.pointers.size == 0 && (e.viewMode.value = "edge", le(a).forEach(([z, L]) => {
      document.addEventListener(z, L);
    }), s.pointerPeekCount = 0), s.pointerPeekCount++;
    const x = {
      pointerId: y.pointerId,
      id: p,
      eventTarget: y.currentTarget
    };
    s.pointers.set(y.pointerId, x), i.emit("edge:pointerdown", he(p, y));
  }
  function g(p, y) {
    p.forEach((x) => t.add(x)), i.emit("edge:pointerover", he(p, y));
  }
  function v(p, y) {
    p.forEach((x) => t.delete(x)), i.emit("edge:pointerout", he(p, y));
  }
  function w(p, y) {
    f(p, y);
  }
  function E(p, y) {
    r(p, y);
  }
  function m(p, y) {
    y.stopPropagation(), i.emit("edge:contextmenu", he(p, y));
  }
  return {
    handleEdgePointerDownEvent: c,
    handleEdgePointerOverEvent: l,
    handleEdgePointerOutEvent: d,
    handleEdgeClickEvent: f,
    handleEdgeDoubleClickEvent: r,
    handleEdgeContextMenu: b,
    handleEdgesPointerDownEvent: k,
    handleEdgesPointerOverEvent: g,
    handleEdgesPointerOutEvent: v,
    handleEdgesClickEvent: w,
    handleEdgesDoubleClickEvent: E,
    handleEdgesContextMenu: m
  };
}
function he(n, e) {
  return n instanceof Array ? {
    edges: n,
    event: e,
    summarized: !0
  } : {
    edge: n,
    edges: [n],
    event: e,
    summarized: !1
  };
}
function Bi(n, e, t, o) {
  const i = {
    moveCounter: 0,
    pointerCounter: 0,
    clickState: void 0
  }, s = {
    pointermove: c,
    pointerup: u,
    pointercancel: u
  };
  function a(d) {
    i.moveCounter = 0, i.pointerCounter === 0 && le(s).forEach(([b, k]) => {
      document.addEventListener(b, k, { passive: !0 });
    }), i.pointerCounter++;
  }
  function c(d) {
    i.moveCounter++;
  }
  function u(d) {
    if (i.pointerCounter--, i.pointerCounter <= 0) {
      i.pointerCounter = 0, le(s).forEach(([k, g]) => {
        document.removeEventListener(k, g);
      });
      const b = tt(d.pointerType);
      if (i.moveCounter <= b) {
        if (d.shiftKey && e.selectionMode.value !== "container")
          return;
        e.selectionMode.value = "container";
        const [k, g, v] = Yn(
          i.clickState,
          d,
          "view"
        );
        i.clickState = k, n.value.dispatchEvent(g), v && n.value.dispatchEvent(v);
      }
    }
  }
  function h(d) {
    d.isTrusted || (d.stopPropagation(), o.emit("view:click", { event: d }));
  }
  function f(d) {
    d.isTrusted || (d.stopPropagation(), o.emit("view:dblclick", { event: d }));
  }
  function r(d) {
    o.emit("view:contextmenu", { event: d }), i.pointerCounter > 0 && (i.pointerCounter = 0, le(s).forEach(([b, k]) => {
      var g;
      (g = n.value) == null || g.removeEventListener(b, k);
    }));
  }
  const l = (d) => {
    d.preventDefault();
  };
  je(() => {
    const d = n.value;
    d && (d.addEventListener("pointerdown", a, { passive: !0 }), d.addEventListener("click", h, { passive: !1 }), d.addEventListener("dblclick", f, { passive: !1 }), d.addEventListener("contextmenu", r, { passive: !1 }), t.value && d.addEventListener("wheel", l, { passive: !1 }));
  }), Xe(() => {
    const d = n.value;
    d && (d.removeEventListener("pointerdown", a), d.removeEventListener("click", h), d.removeEventListener("dblclick", f), d.removeEventListener("contextmenu", r), t.value && d.removeEventListener("wheel", l));
  }), F(t, (d, b) => {
    const k = n.value;
    !k || d === b || (d ? k.addEventListener("wheel", l, { passive: !1 }) : k.removeEventListener("wheel", l));
  });
}
function Ri(n, e, t, o, i, s) {
  const a = {
    pointers: /* @__PURE__ */ new Map(),
    // <PointerId, ...>
    pointerPeekCount: 0,
    clicks: /* @__PURE__ */ new Map()
  };
  function c(v, w) {
    var E, m;
    return i.value ? { path: (m = (E = n[v]) == null ? void 0 : E.path) != null ? m : v, event: w } : { path: v, event: w };
  }
  const u = {
    pointerup: f,
    pointercancel: r
  };
  F(o, (v) => {
    v.size > 0 && e.selectionMode.value !== "path" ? e.selectionMode.value = "path" : v.size === 0 && e.selectionMode.value === "path" && (e.selectionMode.value = "container");
  }), F(e.selectionMode, (v) => {
    v !== "path" && o.clear();
  });
  function h(v, w) {
    var m;
    if (!((m = n[v]) != null && m.clickable) || w.button == 2 || (w.stopPropagation(), !["default", "path"].includes(e.viewMode.value)))
      return;
    a.pointers.size == 0 && (e.viewMode.value = "path", le(u).forEach(([p, y]) => {
      document.addEventListener(p, y);
    }), a.pointerPeekCount = 0), a.pointerPeekCount++;
    const E = {
      pointerId: w.pointerId,
      id: v,
      eventTarget: w.currentTarget
    };
    a.pointers.set(w.pointerId, E), s.emit("path:pointerdown", c(v, w));
  }
  function f(v) {
    var y, x;
    const w = a.pointers.get(v.pointerId);
    if (!w)
      return;
    v.stopPropagation(), a.pointers.delete(v.pointerId);
    const E = w.id;
    s.emit("path:pointerup", c(E, v));
    const [m, p] = qt(
      a.clicks,
      w.pointerId,
      E,
      v
    );
    (y = w.eventTarget) == null || y.dispatchEvent(m), p && ((x = w.eventTarget) == null || x.dispatchEvent(p)), a.pointers.size === 0 && (a.pointerPeekCount = 0, le(u).forEach(([z, L]) => {
      document.removeEventListener(z, L);
    }), Xt(a.clicks), e.viewMode.value = "default");
  }
  function r(v) {
    if (a.pointers.get(v.pointerId)) {
      v.stopPropagation();
      for (const E of a.pointers.values()) {
        const m = E.id;
        s.emit("path:pointerup", c(m, v));
      }
      a.pointers.clear(), a.pointerPeekCount = 0, le(u).forEach(([E, m]) => {
        document.removeEventListener(E, m);
      }), s.emit("view:mode", "default");
    }
  }
  function l(v, w) {
    var E;
    (E = n[v]) != null && E.hoverable && (t.add(v), s.emit("path:pointerover", c(v, w)));
  }
  function d(v, w) {
    var E;
    (E = n[v]) != null && E.hoverable && (t.delete(v), s.emit("path:pointerout", c(v, w)));
  }
  function b(v, w) {
    var m, p, y;
    if (w.isTrusted || !((m = n[v]) != null && m.clickable) || w.shiftKey && !["container", "path"].includes(e.selectionMode.value))
      return;
    e.selectionMode.value = "path";
    const E = (y = (p = n[v]) == null ? void 0 : p.selectable) != null ? y : !1;
    if (E) {
      const x = Ue.valueOf(a.pointers).filter((z) => o.has(z.id)).length > 0;
      w.shiftKey || x ? o.has(v) ? o.delete(v) : typeof E == "number" && o.size >= E || o.add(v) : o.has(v) || (o.clear(), o.add(v));
    }
    s.emit("path:click", c(v, w));
  }
  function k(v, w) {
    var E;
    w.isTrusted || (E = n[v]) != null && E.clickable && s.emit("path:dblclick", c(v, w));
  }
  function g(v, w) {
    var E;
    (E = n[v]) != null && E.clickable && (w.stopPropagation(), s.emit("path:contextmenu", c(v, w)));
  }
  return {
    handlePathPointerDownEvent: h,
    handlePathPointerOverEvent: l,
    handlePathPointerOutEvent: d,
    handlePathClickEvent: b,
    handlePathDoubleClickEvent: k,
    handlePathContextMenu: g
  };
}
function Vi(n) {
  return pe(this, null, function* () {
    const t = yield (yield fetch(n)).blob();
    return new Promise((o, i) => {
      try {
        const s = new FileReader();
        s.onload = function() {
          o(this.result);
        }, s.readAsDataURL(t);
      } catch (s) {
        i(s);
      }
    });
  });
}
function $t(n, e, t) {
  var s;
  const o = n.createSVGPoint();
  o.x = t.x, o.y = t.y;
  const i = o.matrixTransform((s = e.getCTM()) == null ? void 0 : s.inverse());
  return { x: i.x, y: i.y };
}
function Wi(n, e, t) {
  const o = n.createSVGPoint();
  o.x = t.x, o.y = t.y;
  const i = o.matrixTransform(e.getCTM());
  return { x: i.x, y: i.y };
}
function Qn(n, e, t) {
  var h;
  const o = n.cloneNode(!0), i = e.getBBox(), s = 1 / t, a = {
    x: Math.floor((i.x - 10) * s),
    y: Math.floor((i.y - 10) * s),
    width: Math.ceil((i.width + 20) * s),
    height: Math.ceil((i.height + 20) * s)
  };
  o.setAttribute("width", a.width.toString()), o.setAttribute("height", a.height.toString());
  const c = o.querySelector(".v-ng-viewport");
  c.setAttribute("transform", `translate(${-a.x} ${-a.y}), scale(${s})`), c.removeAttribute("style"), o.setAttribute("viewBox", `0 0 ${a.width} ${a.height}`), o.removeAttribute("style");
  const u = document.createNodeIterator(o, NodeFilter.SHOW_COMMENT);
  for (; u.nextNode(); ) {
    const f = u.referenceNode;
    (h = f.parentNode) == null || h.removeChild(f);
  }
  return o;
}
function Hi(n) {
  return pe(this, null, function* () {
    let e = !1, t = n.getAttribute("href");
    if (t || (e = !0, t = n.getAttribute("xlink:href")), !(!t || t.startsWith("data:")))
      try {
        const o = yield Vi(t);
        n.setAttribute(e ? "xlink:href" : "href", o);
      } catch (o) {
        console.warn("Image download failed.", t);
        return;
      }
  });
}
function Ui(i, s, a) {
  return pe(this, arguments, function* (n, e, t, o = {}) {
    const c = Qn(n, e, t);
    if (o.embedImages) {
      const h = Array.from(c.querySelectorAll("image")).map((f) => Hi(f));
      yield Promise.all(h);
    }
    return c;
  });
}
function Fi(n, e, t, o, i, s) {
  const a = O(
    () => !!s.node.selectable && s.view.boxSelectionEnabled
  ), c = O(() => e.viewMode.value === "box-selection"), u = j(), h = j(), f = {
    pointers: /* @__PURE__ */ new Set(),
    // Set of pointers being pressed
    points: /* @__PURE__ */ new Map(),
    // Point indicated by each pointer
    startPoint: null,
    // Point where the drag started
    selectedNodesAtSelectStarted: /* @__PURE__ */ new Set(),
    // Nodes selected at the start of the selection
    selectionType: "append",
    // Selection method for nodes included in the dragged range
    options: {
      // options specified by user at start of selection mode
      stopTrigger: "pointerup",
      selectionType: "append",
      selectionTypeWithShiftKey: "same"
    }
  }, r = Wo(
    () => {
      qi(
        q(n.value, "container"),
        q(u.value, "viewport"),
        h,
        t.nodes,
        o,
        i,
        f.selectedNodesAtSelectStarted,
        f.selectionType
      );
    },
    50,
    { maxWait: 100 }
  ), l = new Xi(
    n,
    b,
    k,
    g,
    d,
    v
  );
  function d(y) {
    if (f.options.stopTrigger !== "click" || f.pointers.size > 0) return;
    const x = { x: y.offsetX, y: y.offsetY };
    f.startPoint && R.fromObject(f.startPoint).distance(x) > 10 || p();
  }
  function b(y) {
    y.stopPropagation();
    const x = { x: y.offsetX, y: y.offsetY };
    f.pointers.size === 0 && (f.startPoint = x, l.activate(), f.selectedNodesAtSelectStarted.clear(), i.forEach((z) => f.selectedNodesAtSelectStarted.add(z)), f.options.selectionTypeWithShiftKey === "same" ? f.selectionType = f.options.selectionType : f.selectionType = y.shiftKey ? f.options.selectionTypeWithShiftKey : f.options.selectionType), f.pointers.has(y.pointerId) || f.pointers.add(y.pointerId), f.points.set(y.pointerId, x), w();
  }
  function k(y) {
    if (f.pointers.delete(y.pointerId), f.pointers.size === 1) {
      const x = q(n.value).getBoundingClientRect(), z = { x: y.x - x.x, y: y.y - x.y };
      f.startPoint = z;
    } else f.pointers.size === 0 && (l.deactivate(), f.options.stopTrigger === "pointerup" && p(), f.selectedNodesAtSelectStarted.clear());
    w();
  }
  function g(y) {
    const x = q(n.value).getBoundingClientRect(), z = { x: y.x - x.x, y: y.y - x.y };
    f.points.set(y.pointerId, z), w(), r();
  }
  function v(y) {
    y.key === "Escape" && f.options.stopTrigger !== "manual" && (y.stopPropagation(), p());
  }
  function w() {
    let y, x;
    const z = Array.from(f.pointers);
    if (z.length >= 2) {
      const L = z[0], C = z[z.length - 1];
      y = f.points.get(L), x = f.points.get(C);
    } else if (f.startPoint && z.length === 1) {
      const L = z[0];
      y = f.startPoint, x = f.points.get(L);
    } else
      y = void 0, x = void 0;
    y && x ? (h.value = {
      pos: {
        x: Math.min(y.x, x.x),
        y: Math.min(y.y, x.y)
      },
      size: {
        width: Math.abs(x.x - y.x),
        height: Math.abs(x.y - y.y)
      }
    }, h.value.size.width === 0 && (h.value.size.width = 1), h.value.size.height === 0 && (h.value.size.height = 1)) : h.value && (h.value = void 0);
  }
  const E = new Gi(
    n,
    // key down
    (y) => {
      a.value && s.view.selection.detector(y) && (m({
        stop: "manual",
        type: "append",
        withShiftKey: "invert"
      }), E.activate());
    },
    // key up
    (y) => {
      a.value && s.view.selection.detector(y) && (f.pointers.size === 0 ? p() : f.options.stopTrigger = "pointerup", E.deactivate());
    }
  );
  F(a, (y) => {
    y ? E.register() : E.unregister();
  }), je(() => {
    var y;
    u.value = (y = n.value) == null ? void 0 : y.querySelector(".v-ng-viewport"), a.value && E.register();
  }), Xe(() => {
    p(), a.value && E.unregister();
  });
  function m(y = {}) {
    var x, z, L;
    f.options = {
      stopTrigger: (x = y.stop) != null ? x : "pointerup",
      selectionType: (z = y.type) != null ? z : "append",
      selectionTypeWithShiftKey: (L = y.withShiftKey) != null ? L : "same"
    }, e.viewMode.value !== "box-selection" && (e.viewMode.value = "box-selection", f.pointers.clear(), l.register());
  }
  function p() {
    e.viewMode.value === "box-selection" && (e.viewMode.value = "default", l.unregister());
  }
  return { isBoxSelectionMode: c, selectionBox: h, startBoxSelection: m, stopBoxSelection: p };
}
function qi(n, e, t, o, i, s, a, c) {
  if (!t.value) return;
  const u = t.value, h = $t(n, e, u.pos), f = $t(n, e, {
    x: u.pos.x + u.size.width,
    y: u.pos.y + u.size.height
  }), r = new Set(
    Object.entries(o).filter(([l, d]) => h.x <= d.x && d.x <= f.x && h.y <= d.y && d.y <= f.y).map(([l, d]) => l)
  );
  if (c === "append")
    s.forEach((l) => {
      r.has(l) || s.delete(l);
    }), r.forEach((l) => {
      var b, k;
      const d = (k = (b = i[l]) == null ? void 0 : b.selectable) != null ? k : !1;
      (d === !0 || typeof d == "number" && s.size < d) && s.add(l);
    });
  else {
    const l = new Set(a);
    l.forEach((d) => {
      r.has(d) && l.delete(d);
    }), r.forEach((d) => {
      var b, k;
      if (!a.has(d)) {
        const g = (k = (b = i[d]) == null ? void 0 : b.selectable) != null ? k : !1;
        (g === !0 || typeof g == "number" && l.size < g) && l.add(d);
      }
    }), s.clear(), l.forEach((d) => s.add(d));
  }
}
class Xi {
  constructor(e, t, o, i, s, a) {
    this._container = e, this._handlePointerDownEvent = t, this._handlePointerUpEvent = o, this._handlePointerMoveEvent = i, this._handleClickEvent = s, this._handleKeyDownEvent = a, this._ignoreEvent = (c) => c.stopPropagation();
  }
  register() {
    const e = { capture: !0, passive: !1 }, t = q(this._container.value, "container");
    t.addEventListener("pointerdown", this._handlePointerDownEvent, e), t.addEventListener("click", this._handleClickEvent, e), t.addEventListener("pointerenter", this._ignoreEvent, e), t.addEventListener("pointerleave", this._ignoreEvent, e), document.addEventListener("keydown", this._handleKeyDownEvent, e);
  }
  activate() {
    const e = { capture: !0, passive: !1 };
    document.addEventListener("pointermove", this._handlePointerMoveEvent, e), document.addEventListener("pointerup", this._handlePointerUpEvent, e);
  }
  deactivate() {
    const e = { capture: !0 };
    document.removeEventListener("pointermove", this._handlePointerMoveEvent, e), document.removeEventListener("pointerup", this._handlePointerUpEvent, e);
  }
  unregister() {
    this.deactivate();
    const e = { capture: !0 };
    if (this._container.value) {
      const t = this._container.value;
      t.removeEventListener("pointerdown", this._handlePointerDownEvent, e), t.removeEventListener("click", this._handleClickEvent, e), t.removeEventListener("pointerenter", this._ignoreEvent, e), t.removeEventListener("pointerleave", this._ignoreEvent, e), document.removeEventListener("keydown", this._handleKeyDownEvent, e);
    }
  }
}
class Gi {
  constructor(e, t, o) {
    this._container = e, this._handleKeyDownEvent = t, this._handleKeyUpEvent = o, this._preventDefault = (i) => {
      i.stopPropagation(), i.preventDefault();
    };
  }
  register() {
    document.addEventListener("keydown", this._handleKeyDownEvent, { capture: !0, passive: !0 });
  }
  activate() {
    document.addEventListener("keyup", this._handleKeyUpEvent, { capture: !0, passive: !0 }), q(this._container.value, "container").addEventListener("contextmenu", this._preventDefault, { passive: !1 });
  }
  deactivate() {
    document.removeEventListener("keyup", this._handleKeyUpEvent, { capture: !0 }), this._container.value && this._container.value.removeEventListener("contextmenu", this._preventDefault);
  }
  unregister() {
    this.deactivate(), document.removeEventListener("keydown", this._handleKeyDownEvent, { capture: !0 });
  }
}
const Jn = Symbol("mouseEventHandlers");
function Ki(n, e, t, o, i, s, a, c, u, h, f, r, l, d, b, k) {
  const g = {
    selectionMode: j("container"),
    viewMode: j("default")
  };
  a.size > 0 ? g.selectionMode.value = "node" : c.size > 0 ? g.selectionMode.value = "edge" : u.size > 0 && (g.selectionMode.value = "path"), F(g.viewMode, (w) => {
    k.emit("view:mode", w);
  }), Bi(n, g, d, k);
  const v = oe(oe(oe(oe({
    selectedNodes: a,
    hoveredNodes: h,
    selectedEdges: c,
    hoveredEdges: f,
    selectedPaths: u,
    hoveredPaths: r
  }, Ni(
    o,
    e,
    g,
    h,
    a,
    t,
    k
  )), ji(i, g, f, c, k)), Ri(
    s,
    g,
    r,
    u,
    l,
    k
  )), Fi(
    n,
    g,
    e,
    o,
    a,
    b
  ));
  return Me(Jn, v), v;
}
function Ye() {
  return q(Ce(Jn), "mouseEventHandlers");
}
function Yi(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(e, t) {
    var o = n.get(e);
    o ? o.push(t) : n.set(e, [t]);
  }, off: function(e, t) {
    var o = n.get(e);
    o && (t ? o.splice(o.indexOf(t) >>> 0, 1) : n.set(e, []));
  }, emit: function(e, t) {
    var o = n.get(e);
    o && o.slice().map(function(i) {
      i(t);
    }), (o = n.get("*")) && o.slice().map(function(i) {
      i(e, t);
    });
  } };
}
const eo = Symbol("emitter");
function Qi() {
  const n = Yi();
  return Me(eo, n), n;
}
function Ji() {
  return q(Ce(eo), "event emitter");
}
var wn = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function es(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var kt, En;
function dt() {
  if (En) return kt;
  En = 1, kt = {
    /**
     * Get global this object
     *
     * @return {Object}        global this object
     */
    getGlobalThis: function() {
      if (typeof globalThis != "undefined") return globalThis;
      if (typeof self != "undefined") return self;
      if (typeof window != "undefined") return window;
      if (typeof wn != "undefined") return wn;
      if (typeof this != "undefined") return this;
      throw new Error("Unable to locate global `this`");
    },
    /**
     * Extends an object
     *
     * @param  {Object} target object to extend
     * @param  {Object} source object to take properties from
     * @return {Object}        extended object
     */
    extend: function(e, t) {
      e = e || {};
      for (var o in t)
        this.isObject(t[o]) ? e[o] = this.extend(e[o], t[o]) : e[o] = t[o];
      return e;
    },
    /**
     * Checks if an object is a DOM element
     *
     * @param  {Object}  o HTML element or String
     * @return {Boolean}   returns true if object is a DOM element
     */
    isElement: function(e) {
      return e instanceof HTMLElement || e instanceof SVGElement || e instanceof SVGSVGElement || //DOM2
      e && typeof e == "object" && e !== null && e.nodeType === 1 && typeof e.nodeName == "string";
    },
    /**
     * Checks if an object is an Object
     *
     * @param  {Object}  o Object
     * @return {Boolean}   returns true if object is an Object
     */
    isObject: function(e) {
      return Object.prototype.toString.call(e) === "[object Object]";
    },
    /**
     * Checks if variable is Number
     *
     * @param  {Integer|Float}  n
     * @return {Boolean}   returns true if variable is Number
     */
    isNumber: function(e) {
      return !isNaN(parseFloat(e)) && isFinite(e);
    },
    /**
     * Search for an SVG element
     *
     * @param  {Object|String} elementOrSelector DOM Element or selector String
     * @return {Object|Null}                   SVG or null
     */
    getSvg: function(e) {
      var t, o;
      if (this.isElement(e))
        t = e;
      else if (typeof e == "string" || e instanceof String) {
        if (t = document.querySelector(e), !t)
          throw new Error(
            "Provided selector did not find any elements. Selector: " + e
          );
      } else
        throw new Error("Provided selector is not an HTML object nor String");
      if (t.tagName.toLowerCase() === "svg")
        o = t;
      else if (t.tagName.toLowerCase() === "object")
        o = t.contentDocument.documentElement;
      else if (t.tagName.toLowerCase() === "embed")
        o = t.getSVGDocument().documentElement;
      else
        throw t.tagName.toLowerCase() === "img" ? new Error(
          'Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.'
        ) : new Error("Cannot get SVG.");
      return o;
    },
    /**
     * Attach a given context to a function
     * @param  {Function} fn      Function
     * @param  {Object}   context Context
     * @return {Function}           Function with certain context
     */
    proxy: function(e, t) {
      return function() {
        return e.apply(t, arguments);
      };
    },
    /**
     * Returns object type
     * Uses toString that returns [object SVGPoint]
     * And than parses object type from string
     *
     * @param  {Object} o Any object
     * @return {String}   Object type
     */
    getType: function(e) {
      return Object.prototype.toString.apply(e).replace(/^\[object\s/, "").replace(/\]$/, "");
    },
    /**
     * If it is a touch event than add clientX and clientY to event object
     *
     * @param  {Event} evt
     * @param  {SVGSVGElement} svg
     */
    mouseAndTouchNormalize: function(e, t) {
      if (e.clientX === void 0 || e.clientX === null)
        if (e.clientX = 0, e.clientY = 0, e.touches !== void 0 && e.touches.length) {
          if (e.touches[0].clientX !== void 0)
            e.clientX = e.touches[0].clientX, e.clientY = e.touches[0].clientY;
          else if (e.touches[0].pageX !== void 0) {
            var o = t.getBoundingClientRect();
            e.clientX = e.touches[0].pageX - o.left, e.clientY = e.touches[0].pageY - o.top;
          }
        } else e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY);
    },
    /**
     * If it is a touch event than add clientX and clientY to event object
     *
     * @param  {Event} evt
     * @param  {SVGSVGElement} svg
     * @param  {Number} touch
     */
    touchNormalize: function(e, t, o) {
      if (e.touches !== void 0 && e.touches.length) {
        if (e.touches[o].clientX !== void 0)
          e.clientX = e.touches[o].clientX, e.clientY = e.touches[o].clientY;
        else if (e.touches[o].pageX !== void 0) {
          var i = t.getBoundingClientRect();
          e.clientX = e.touches[o].pageX - i.left, e.clientY = e.touches[o].pageY - i.top;
        }
      } else
        (e.clientX === void 0 || e.clientX === null) && (e.clientX = 0, e.clientY = 0, e.originalEvent !== void 0 && e.originalEvent.clientX !== void 0 && (e.clientX = e.originalEvent.clientX, e.clientY = e.originalEvent.clientY));
    },
    /**
     * Check if an event is a double click/tap
     * TODO: For touch gestures use a library (hammer.js) that takes in account other events
     * (touchmove and touchend). It should take in account tap duration and traveled distance
     *
     * @param  {Event}  evt
     * @param  {Event}  prevEvt Previous Event
     * @return {Boolean}
     */
    isDblClick: function(e, t) {
      if (e.detail === 2)
        return !0;
      if (t != null) {
        var o = e.timeStamp - t.timeStamp, i = Math.sqrt(
          Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)
        );
        return o < 250 && i < 10;
      }
      return !1;
    },
    /**
     * Returns current timestamp as an integer
     *
     * @return {Number}
     */
    now: Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    },
    // From underscore.
    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    throttle: function(e, t, o) {
      var i = this, s, a, c, u = null, h = 0;
      o || (o = {});
      var f = function() {
        h = o.leading === !1 ? 0 : i.now(), u = null, c = e.apply(s, a), u || (s = a = null);
      };
      return function() {
        var r = i.now();
        !h && o.leading === !1 && (h = r);
        var l = t - (r - h);
        return s = this, a = arguments, l <= 0 || l > t ? (clearTimeout(u), u = null, h = r, c = e.apply(s, a), u || (s = a = null)) : !u && o.trailing !== !1 && (u = setTimeout(f, l)), c;
      };
    },
    /**
     * Create a requestAnimationFrame simulation
     *
     * @param  {Number|String} refreshRate
     * @return {Function}
     */
    createRequestAnimationFrame: function(e) {
      var t = null;
      return e !== "auto" && e < 60 && e > 1 && (t = Math.floor(1e3 / e)), t === null ? window.requestAnimationFrame || n(33) : n(t);
    },
    /**
     * Calculate distance of points
     *
     * @param  {SVGPoint} point1
     * @param  {SVGPoint} point2
     * @return {Number}
     */
    calculateDistance: function(e, t) {
      var o = e.x - t.x, i = e.y - t.y;
      return Math.sqrt(o * o + i * i);
    }
  };
  function n(e) {
    return function(t) {
      window.setTimeout(t, e);
    };
  }
  return kt;
}
var xt, kn;
function ts() {
  if (kn) return xt;
  kn = 1;
  var n = dt();
  return xt = function() {
    var e = "", t, o, i, s = [], a = { passive: !0 }, c = { passive: !1 };
    n.getGlobalThis().addEventListener ? (t = "addEventListener", o = "removeEventListener") : (t = "attachEvent", o = "detachEvent", e = "on");
    function u() {
      return i || (i = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll"), i;
    }
    function h(g, v) {
      var w = function(E) {
        !E && (E = window.event);
        var m = {
          // keep a ref to the original event object
          originalEvent: E,
          target: E.target || E.srcElement,
          type: "wheel",
          deltaMode: E.type == "MozMousePixelScroll" ? 0 : 1,
          deltaX: 0,
          delatZ: 0,
          preventDefault: function() {
            E.preventDefault ? E.preventDefault() : E.returnValue = !1;
          }
        };
        return u() == "mousewheel" ? (m.deltaY = -0.025 * E.wheelDelta, E.wheelDeltaX && (m.deltaX = -0.025 * E.wheelDeltaX)) : m.deltaY = E.detail, v(m);
      };
      return s.push({
        element: g,
        fn: w
      }), w;
    }
    function f(g) {
      for (var v = 0; v < s.length; v++)
        if (s[v].element === g)
          return s[v].fn;
      return function() {
      };
    }
    function r(g) {
      for (var v = 0; v < s.length; v++)
        if (s[v].element === g)
          return s.splice(v, 1);
    }
    function l(g, v, w, E) {
      var m;
      u() === "wheel" ? m = w : m = h(g, w), g[t](
        e + v,
        m,
        E ? a : c
      );
    }
    function d(g, v, w, E) {
      var m;
      u() === "wheel" ? m = w : m = f(g), g[o](
        e + v,
        m,
        E ? a : c
      ), r(g);
    }
    function b(g, v, w) {
      l(g, u(), v, w), u() == "DOMMouseScroll" && l(
        g,
        "MozMousePixelScroll",
        v,
        w
      );
    }
    function k(g, v, w) {
      d(g, u(), v, w), u() == "DOMMouseScroll" && d(
        g,
        "MozMousePixelScroll",
        v,
        w
      );
    }
    return {
      on: b,
      off: k
    };
  }(), xt;
}
var We, xn;
function Gt() {
  if (xn) return We;
  xn = 1;
  var n = dt(), e = "unknown";
  return (
    /*@cc_on!@*/
    typeof document != "undefined" && document.documentMode && (e = "ie"), We = {
      svgNS: "http://www.w3.org/2000/svg",
      xmlNS: "http://www.w3.org/XML/1998/namespace",
      xmlnsNS: "http://www.w3.org/2000/xmlns/",
      xlinkNS: "http://www.w3.org/1999/xlink",
      evNS: "http://www.w3.org/2001/xml-events",
      /**
       * Get svg dimensions: width and height
       *
       * @param  {SVGSVGElement} svg
       * @return {Object}     {width: 0, height: 0}
       */
      getBoundingClientRectNormalized: function(t) {
        if (t.clientWidth && t.clientHeight)
          return { width: t.clientWidth, height: t.clientHeight };
        if (t.getBoundingClientRect())
          return t.getBoundingClientRect();
        throw new Error("Cannot get BoundingClientRect for SVG.");
      },
      /**
       * Gets g element with class of "viewport" or creates it if it doesn't exist
       *
       * @param  {SVGSVGElement} svg
       * @return {SVGElement}     g (group) element
       */
      getOrCreateViewport: function(t, o) {
        var i = null;
        if (n.isElement(o) ? i = o : i = t.querySelector(o), !i) {
          var s = Array.prototype.slice.call(t.childNodes || t.children).filter(function(f) {
            return f.nodeName !== "defs" && f.nodeName !== "#text";
          });
          s.length === 1 && s[0].nodeName === "g" && s[0].getAttribute("transform") === null && (i = s[0]);
        }
        if (!i) {
          var a = "viewport-" + (/* @__PURE__ */ new Date()).toISOString().replace(/\D/g, "");
          i = document.createElementNS(this.svgNS, "g"), i.setAttribute("id", a);
          var c = t.childNodes || t.children;
          if (c && c.length > 0)
            for (var u = c.length; u > 0; u--)
              c[c.length - u].nodeName !== "defs" && i.appendChild(c[c.length - u]);
          t.appendChild(i);
        }
        var h = [];
        return i.getAttribute("class") && (h = i.getAttribute("class").split(" ")), ~h.indexOf("svg-pan-zoom_viewport") || (h.push("svg-pan-zoom_viewport"), i.setAttribute("class", h.join(" "))), i;
      },
      /**
       * Set SVG attributes
       *
       * @param  {SVGSVGElement} svg
       */
      setupSvgAttributes: function(t) {
        if (t.setAttribute("xmlns", this.svgNS), t.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS), t.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS), t.parentNode !== null) {
          var o = t.getAttribute("style") || "";
          o.toLowerCase().indexOf("overflow") === -1 && t.setAttribute("style", "overflow: hidden; " + o);
        }
      },
      /**
       * How long Internet Explorer takes to finish updating its display (ms).
       */
      internetExplorerRedisplayInterval: 300,
      /**
       * Forces the browser to redisplay all SVG elements that rely on an
       * element defined in a 'defs' section. It works globally, for every
       * available defs element on the page.
       * The throttling is intentionally global.
       *
       * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)
       * visible after pan/zoom when there are multiple SVGs on the page.
       * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/
       * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62
       */
      refreshDefsGlobal: n.throttle(
        function() {
          for (var t = document.querySelectorAll("defs"), o = t.length, i = 0; i < o; i++) {
            var s = t[i];
            s.parentNode.insertBefore(s, s);
          }
        },
        We ? We.internetExplorerRedisplayInterval : null
      ),
      /**
       * Sets the current transform matrix of an element
       *
       * @param {SVGElement} element
       * @param {SVGMatrix} matrix  CTM
       * @param {SVGElement} defs
       */
      setCTM: function(t, o, i) {
        var s = this, a = "matrix(" + o.a + "," + o.b + "," + o.c + "," + o.d + "," + o.e + "," + o.f + ")";
        t.setAttributeNS(null, "transform", a), "transform" in t.style ? t.style.transform = a : "-ms-transform" in t.style ? t.style["-ms-transform"] = a : "-webkit-transform" in t.style && (t.style["-webkit-transform"] = a), e === "ie" && i && (i.parentNode.insertBefore(i, i), window.setTimeout(function() {
          s.refreshDefsGlobal();
        }, s.internetExplorerRedisplayInterval));
      },
      /**
       * Instantiate an SVGPoint object with given event coordinates
       *
       * @param {Event} evt
       * @param  {SVGSVGElement} svg
       * @return {SVGPoint}     point
       */
      getEventPoint: function(t, o) {
        var i = o.createSVGPoint();
        return n.mouseAndTouchNormalize(t, o), i.x = t.clientX, i.y = t.clientY, i;
      },
      /**
       * Instantiate an SVGPoint object with given touch event coordinates
       *
       * @param {Event} evt
       * @param  {SVGSVGElement} svg
       * @param  {Number} touch
       * @return {SVGPoint}     point
       */
      getTouchPoint: function(t, o, i) {
        var s = o.createSVGPoint();
        return n.touchNormalize(t, o, i), s.x = t.clientX, s.y = t.clientY, s;
      },
      /**
       * Get SVG center point
       *
       * @param  {SVGSVGElement} svg
       * @return {SVGPoint}
       */
      getSvgCenterPoint: function(t, o, i) {
        return this.createSVGPoint(t, o / 2, i / 2);
      },
      /**
       * Create a SVGPoint with given x and y
       *
       * @param  {SVGSVGElement} svg
       * @param  {Number} x
       * @param  {Number} y
       * @return {SVGPoint}
       */
      createSVGPoint: function(t, o, i) {
        var s = t.createSVGPoint();
        return s.x = o, s.y = i, s;
      }
    }, We
  );
}
var Pt, Pn;
function ns() {
  if (Pn) return Pt;
  Pn = 1;
  var n = Gt();
  return Pt = {
    enable: function(e) {
      var t = e.svg.querySelector("defs");
      t || (t = document.createElementNS(n.svgNS, "defs"), e.svg.appendChild(t));
      var o = t.querySelector("style#svg-pan-zoom-controls-styles");
      if (!o) {
        var i = document.createElementNS(n.svgNS, "style");
        i.setAttribute("id", "svg-pan-zoom-controls-styles"), i.setAttribute("type", "text/css"), i.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }", t.appendChild(i);
      }
      var s = document.createElementNS(n.svgNS, "g");
      s.setAttribute("id", "svg-pan-zoom-controls"), s.setAttribute(
        "transform",
        "translate(" + (e.width - 70) + " " + (e.height - 76) + ") scale(0.75)"
      ), s.setAttribute("class", "svg-pan-zoom-control"), s.appendChild(this._createZoomIn(e)), s.appendChild(this._createZoomReset(e)), s.appendChild(this._createZoomOut(e)), e.svg.appendChild(s), e.controlIcons = s;
    },
    _createZoomIn: function(e) {
      var t = document.createElementNS(n.svgNS, "g");
      t.setAttribute("id", "svg-pan-zoom-zoom-in"), t.setAttribute("transform", "translate(30.5 5) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
        "click",
        function() {
          e.getPublicInstance().zoomIn();
        },
        !1
      ), t.addEventListener(
        "touchstart",
        function() {
          e.getPublicInstance().zoomIn();
        },
        !1
      );
      var o = document.createElementNS(n.svgNS, "rect");
      o.setAttribute("x", "0"), o.setAttribute("y", "0"), o.setAttribute("width", "1500"), o.setAttribute("height", "1400"), o.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(o);
      var i = document.createElementNS(n.svgNS, "path");
      return i.setAttribute(
        "d",
        "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z"
      ), i.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(i), t;
    },
    _createZoomReset: function(e) {
      var t = document.createElementNS(n.svgNS, "g");
      t.setAttribute("id", "svg-pan-zoom-reset-pan-zoom"), t.setAttribute("transform", "translate(5 35) scale(0.4)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
        "click",
        function() {
          e.getPublicInstance().reset();
        },
        !1
      ), t.addEventListener(
        "touchstart",
        function() {
          e.getPublicInstance().reset();
        },
        !1
      );
      var o = document.createElementNS(
        n.svgNS,
        "rect"
      );
      o.setAttribute("x", "2"), o.setAttribute("y", "2"), o.setAttribute("width", "182"), o.setAttribute("height", "58"), o.setAttribute(
        "class",
        "svg-pan-zoom-control-background"
      ), t.appendChild(o);
      var i = document.createElementNS(
        n.svgNS,
        "path"
      );
      i.setAttribute(
        "d",
        "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z"
      ), i.setAttribute(
        "class",
        "svg-pan-zoom-control-element"
      ), t.appendChild(i);
      var s = document.createElementNS(
        n.svgNS,
        "path"
      );
      return s.setAttribute(
        "d",
        "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z"
      ), s.setAttribute(
        "class",
        "svg-pan-zoom-control-element"
      ), t.appendChild(s), t;
    },
    _createZoomOut: function(e) {
      var t = document.createElementNS(n.svgNS, "g");
      t.setAttribute("id", "svg-pan-zoom-zoom-out"), t.setAttribute("transform", "translate(30.5 70) scale(0.015)"), t.setAttribute("class", "svg-pan-zoom-control"), t.addEventListener(
        "click",
        function() {
          e.getPublicInstance().zoomOut();
        },
        !1
      ), t.addEventListener(
        "touchstart",
        function() {
          e.getPublicInstance().zoomOut();
        },
        !1
      );
      var o = document.createElementNS(n.svgNS, "rect");
      o.setAttribute("x", "0"), o.setAttribute("y", "0"), o.setAttribute("width", "1500"), o.setAttribute("height", "1400"), o.setAttribute("class", "svg-pan-zoom-control-background"), t.appendChild(o);
      var i = document.createElementNS(n.svgNS, "path");
      return i.setAttribute(
        "d",
        "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z"
      ), i.setAttribute("class", "svg-pan-zoom-control-element"), t.appendChild(i), t;
    },
    disable: function(e) {
      e.controlIcons && (e.controlIcons.parentNode.removeChild(e.controlIcons), e.controlIcons = null);
    }
  }, Pt;
}
var St, Sn;
function os() {
  if (Sn) return St;
  Sn = 1;
  var n = Gt(), e = dt(), t = function(o, i) {
    this.init(o, i);
  };
  return t.prototype.init = function(o, i) {
    this.viewport = o, this.options = i, this.originalState = { zoom: 1, x: 0, y: 0 }, this.activeState = { zoom: 1, x: 0, y: 0 }, this.updateCTMCached = e.proxy(this.updateCTM, this), this.requestAnimationFrame = e.createRequestAnimationFrame(
      this.options.refreshRate
    ), this.viewBox = { x: 0, y: 0, width: 0, height: 0 }, this.cacheViewBox();
    var s = this.processCTM();
    this.setCTM(s), this.updateCTM();
  }, t.prototype.cacheViewBox = function() {
    var o = this.options.svg.getAttribute("viewBox");
    if (o) {
      var i = o.split(/[\s\,]/).filter(function(a) {
        return a;
      }).map(parseFloat);
      this.viewBox.x = i[0], this.viewBox.y = i[1], this.viewBox.width = i[2], this.viewBox.height = i[3];
      var s = Math.min(
        this.options.width / this.viewBox.width,
        this.options.height / this.viewBox.height
      );
      this.activeState.zoom = isFinite(s) ? s : 1, this.activeState.x = (this.options.width - this.viewBox.width * s) / 2, this.activeState.y = (this.options.height - this.viewBox.height * s) / 2, this.updateCTMOnNextFrame(), this.options.svg.removeAttribute("viewBox");
    } else
      this.simpleViewBoxCache();
  }, t.prototype.simpleViewBoxCache = function() {
    var o = this.viewport.getBBox();
    this.viewBox.x = o.x, this.viewBox.y = o.y, this.viewBox.width = o.width, this.viewBox.height = o.height;
  }, t.prototype.getViewBox = function() {
    return e.extend({}, this.viewBox);
  }, t.prototype.processCTM = function() {
    var o = this.getCTM();
    if (this.options.fit || this.options.contain) {
      var i;
      this.options.fit ? i = Math.min(
        this.options.width / this.viewBox.width,
        this.options.height / this.viewBox.height
      ) : i = Math.max(
        this.options.width / this.viewBox.width,
        this.options.height / this.viewBox.height
      ), i = isFinite(i) ? i : 1, o.a = i, o.d = i, o.e = -this.viewBox.x * i, o.f = -this.viewBox.y * i;
    }
    if (this.options.center) {
      var s = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * o.a) * 0.5, a = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * o.a) * 0.5;
      o.e = s, o.f = a;
    }
    return this.originalState.zoom = o.a, this.originalState.x = o.e, this.originalState.y = o.f, o;
  }, t.prototype.getOriginalState = function() {
    return e.extend({}, this.originalState);
  }, t.prototype.getState = function() {
    return e.extend({}, this.activeState);
  }, t.prototype.getZoom = function() {
    return this.activeState.zoom;
  }, t.prototype.getRelativeZoom = function() {
    return this.activeState.zoom / this.originalState.zoom;
  }, t.prototype.computeRelativeZoom = function(o) {
    return o / this.originalState.zoom;
  }, t.prototype.getPan = function() {
    return { x: this.activeState.x, y: this.activeState.y };
  }, t.prototype.getCTM = function() {
    var o = this.options.svg.createSVGMatrix();
    return o.a = this.activeState.zoom, o.b = 0, o.c = 0, o.d = this.activeState.zoom, o.e = this.activeState.x, o.f = this.activeState.y, o;
  }, t.prototype.setCTM = function(o) {
    var i = this.isZoomDifferent(o), s = this.isPanDifferent(o);
    if (i || s) {
      if (i && (this.options.beforeZoom(
        this.getRelativeZoom(),
        this.computeRelativeZoom(o.a)
      ) === !1 ? (o.a = o.d = this.activeState.zoom, i = !1) : (this.updateCache(o), this.options.onZoom(this.getRelativeZoom()))), s) {
        var a = this.options.beforePan(this.getPan(), {
          x: o.e,
          y: o.f
        }), c = !1, u = !1;
        a === !1 ? (o.e = this.getPan().x, o.f = this.getPan().y, c = u = !0) : e.isObject(a) && (a.x === !1 ? (o.e = this.getPan().x, c = !0) : e.isNumber(a.x) && (o.e = a.x), a.y === !1 ? (o.f = this.getPan().y, u = !0) : e.isNumber(a.y) && (o.f = a.y)), c && u || !this.isPanDifferent(o) ? s = !1 : (this.updateCache(o), this.options.onPan(this.getPan()));
      }
      (i || s) && this.updateCTMOnNextFrame();
    }
  }, t.prototype.isZoomDifferent = function(o) {
    return this.activeState.zoom !== o.a;
  }, t.prototype.isPanDifferent = function(o) {
    return this.activeState.x !== o.e || this.activeState.y !== o.f;
  }, t.prototype.updateCache = function(o) {
    this.activeState.zoom = o.a, this.activeState.x = o.e, this.activeState.y = o.f;
  }, t.prototype.pendingUpdate = !1, t.prototype.updateCTMOnNextFrame = function() {
    this.pendingUpdate || (this.pendingUpdate = !0, this.requestAnimationFrame.call(window, this.updateCTMCached));
  }, t.prototype.updateCTM = function() {
    var o = this.getCTM();
    n.setCTM(this.viewport, o, this.defs), this.pendingUpdate = !1, this.options.onUpdatedCTM && this.options.onUpdatedCTM(o);
  }, St = function(o, i) {
    return new t(o, i);
  }, St;
}
var Mt, Mn;
function is() {
  if (Mn) return Mt;
  Mn = 1;
  var n = ts(), e = ns(), t = dt(), o = Gt(), i = os(), s = function(r, l) {
    this.init(r, l);
  }, a = {
    viewportSelector: ".svg-pan-zoom_viewport",
    // Viewport selector. Can be querySelector string or SVGElement
    panEnabled: !0,
    // enable or disable panning (default enabled)
    controlIconsEnabled: !1,
    // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
    zoomEnabled: !0,
    // enable or disable zooming (default enabled)
    dblClickZoomEnabled: !0,
    // enable or disable zooming by double clicking (default enabled)
    mouseWheelZoomEnabled: !0,
    // enable or disable zooming by mouse wheel (default enabled)
    preventMouseEventsDefault: !0,
    // enable or disable preventDefault for mouse events
    zoomScaleSensitivity: 0.1,
    // Zoom sensitivity
    minZoom: 0.5,
    // Minimum Zoom level
    maxZoom: 10,
    // Maximum Zoom level
    fit: !0,
    // enable or disable viewport fit in SVG (default true)
    contain: !1,
    // enable or disable viewport contain the svg (default false)
    center: !0,
    // enable or disable viewport centering in SVG (default true)
    refreshRate: "auto",
    // Maximum number of frames per second (altering SVG's viewport)
    beforeZoom: null,
    onZoom: null,
    beforePan: null,
    onPan: null,
    customEventsHandler: null,
    eventsListenerElement: null,
    onUpdatedCTM: null
  }, c = { passive: !0 }, u = { passive: !1 };
  s.prototype.init = function(r, l) {
    var d = this;
    this.svg = r, this.defs = r.querySelector("defs"), o.setupSvgAttributes(this.svg), this.options = t.extend(t.extend({}, a), l), this.state = "none";
    var b = o.getBoundingClientRectNormalized(r);
    this.width = b.width, this.height = b.height, this.viewport = i(
      o.getOrCreateViewport(this.svg, this.options.viewportSelector),
      {
        svg: this.svg,
        width: this.width,
        height: this.height,
        fit: this.options.fit,
        contain: this.options.contain,
        center: this.options.center,
        refreshRate: this.options.refreshRate,
        // Put callbacks into functions as they can change through time
        beforeZoom: function(g, v) {
          if (d.viewport && d.options.beforeZoom)
            return d.options.beforeZoom(g, v);
        },
        onZoom: function(g) {
          if (d.viewport && d.options.onZoom)
            return d.options.onZoom(g);
        },
        beforePan: function(g, v) {
          if (d.viewport && d.options.beforePan)
            return d.options.beforePan(g, v);
        },
        onPan: function(g) {
          if (d.viewport && d.options.onPan)
            return d.options.onPan(g);
        },
        onUpdatedCTM: function(g) {
          if (d.viewport && d.options.onUpdatedCTM)
            return d.options.onUpdatedCTM(g);
        }
      }
    );
    var k = this.getPublicInstance();
    k.setBeforeZoom(this.options.beforeZoom), k.setOnZoom(this.options.onZoom), k.setBeforePan(this.options.beforePan), k.setOnPan(this.options.onPan), k.setOnUpdatedCTM(this.options.onUpdatedCTM), this.options.controlIconsEnabled && e.enable(this), this.lastMouseWheelEventTime = Date.now(), this.setupHandlers();
  }, s.prototype.setupHandlers = function() {
    var r = this, l = null;
    if (this.eventListeners = {
      // Mouse down group
      pointerdown: function(g) {
        if (g.pointerType !== "touch") {
          var v = r.handleMouseDown(g, l);
          return l = g, v;
        }
      },
      touchstart: function(g) {
        var v = r.handleTouchStart(g, l);
        return l = g, v;
      },
      // Mouse up group
      pointerup: function(g) {
        if (g.pointerType !== "touch")
          return r.handleMouseUp(g);
      },
      touchend: function(g) {
        return r.handleTouchEnd(g);
      },
      // Mouse move group
      pointermove: function(g) {
        if (g.pointerType !== "touch")
          return r.handleMouseMove(g);
      },
      touchmove: function(g) {
        return r.handleTouchMove(g);
      },
      // Mouse leave group
      pointerleave: function(g) {
        if (g.pointerType !== "touch")
          return r.handleMouseUp(g);
      },
      pointercancel: function(g) {
        if (g.pointerType !== "touch")
          return r.handleMouseUp(g);
      },
      touchleave: function(g) {
        return r.handleTouchEnd(g);
      },
      touchcancel: function(g) {
        return r.handleTouchEnd(g);
      }
    }, this.options.customEventsHandler != null) {
      this.options.customEventsHandler.init({
        svgElement: this.svg,
        eventsListenerElement: this.options.eventsListenerElement,
        instance: this.getPublicInstance()
      });
      var d = this.options.customEventsHandler.haltEventListeners;
      if (d && d.length)
        for (var b = d.length - 1; b >= 0; b--)
          this.eventListeners.hasOwnProperty(d[b]) && delete this.eventListeners[d[b]];
    }
    for (var k in this.eventListeners)
      (this.options.eventsListenerElement || this.svg).addEventListener(
        k,
        this.eventListeners[k],
        this.options.preventMouseEventsDefault ? u : c
      );
    this.options.mouseWheelZoomEnabled && (this.options.mouseWheelZoomEnabled = !1, this.enableMouseWheelZoom());
  }, s.prototype.enableMouseWheelZoom = function() {
    if (!this.options.mouseWheelZoomEnabled) {
      var r = this;
      this.wheelListener = function(d) {
        return r.handleMouseWheel(d);
      };
      var l = !this.options.preventMouseEventsDefault;
      n.on(
        this.options.eventsListenerElement || this.svg,
        this.wheelListener,
        l
      ), this.options.mouseWheelZoomEnabled = !0;
    }
  }, s.prototype.disableMouseWheelZoom = function() {
    if (this.options.mouseWheelZoomEnabled) {
      var r = !this.options.preventMouseEventsDefault;
      n.off(
        this.options.eventsListenerElement || this.svg,
        this.wheelListener,
        r
      ), this.options.mouseWheelZoomEnabled = !1;
    }
  }, s.prototype.handleMouseWheel = function(r) {
    if (!(!this.options.zoomEnabled || this.state !== "none")) {
      this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1);
      var l = r.deltaY || 1, d = Date.now() - this.lastMouseWheelEventTime, b = 3 + Math.max(0, 30 - d);
      this.lastMouseWheelEventTime = Date.now(), "deltaMode" in r && r.deltaMode === 0 && r.wheelDelta && (l = r.deltaY === 0 ? 0 : Math.abs(r.wheelDelta) / r.deltaY), l = -0.3 < l && l < 0.3 ? l : (l > 0 ? 1 : -1) * Math.log(Math.abs(l) + 10) / b;
      var k = this.svg.getScreenCTM().inverse(), g = o.getEventPoint(r, this.svg).matrixTransform(
        k
      ), v = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * l);
      this.zoomAtPoint(v, g);
    }
  }, s.prototype.zoomAtPoint = function(r, l, d) {
    var b = this.viewport.getOriginalState();
    d ? (r = Math.max(
      this.options.minZoom * b.zoom,
      Math.min(this.options.maxZoom * b.zoom, r)
    ), r = r / this.getZoom()) : this.getZoom() * r < this.options.minZoom * b.zoom ? r = this.options.minZoom * b.zoom / this.getZoom() : this.getZoom() * r > this.options.maxZoom * b.zoom && (r = this.options.maxZoom * b.zoom / this.getZoom());
    var k = this.viewport.getCTM(), g = l.matrixTransform(k.inverse()), v = this.svg.createSVGMatrix().translate(g.x, g.y).scale(r).translate(-g.x, -g.y), w = k.multiply(v);
    w.a !== k.a && this.viewport.setCTM(w);
  }, s.prototype.zoom = function(r, l) {
    this.zoomAtPoint(
      r,
      o.getSvgCenterPoint(this.svg, this.width, this.height),
      l
    );
  }, s.prototype.publicZoom = function(r, l) {
    l && (r = this.computeFromRelativeZoom(r)), this.zoom(r, l);
  }, s.prototype.publicZoomAtPoint = function(r, l, d) {
    if (d && (r = this.computeFromRelativeZoom(r)), t.getType(l) !== "SVGPoint")
      if ("x" in l && "y" in l)
        l = o.createSVGPoint(this.svg, l.x, l.y);
      else
        throw new Error("Given point is invalid");
    this.zoomAtPoint(r, l, d);
  }, s.prototype.getZoom = function() {
    return this.viewport.getZoom();
  }, s.prototype.getRelativeZoom = function() {
    return this.viewport.getRelativeZoom();
  }, s.prototype.computeFromRelativeZoom = function(r) {
    return r * this.viewport.getOriginalState().zoom;
  }, s.prototype.resetZoom = function() {
    var r = this.viewport.getOriginalState();
    this.zoom(r.zoom, !0);
  }, s.prototype.resetPan = function() {
    this.pan(this.viewport.getOriginalState());
  }, s.prototype.reset = function() {
    this.resetZoom(), this.resetPan();
  }, s.prototype.handleDblClick = function(r) {
    if (this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), this.options.controlIconsEnabled) {
      var l = r.target.getAttribute("class") || "";
      if (l.indexOf("svg-pan-zoom-control") > -1)
        return !1;
    }
    var d;
    r.shiftKey ? d = 1 / ((1 + this.options.zoomScaleSensitivity) * 2) : d = (1 + this.options.zoomScaleSensitivity) * 2;
    var b = o.getEventPoint(r, this.svg).matrixTransform(
      this.svg.getScreenCTM().inverse()
    );
    this.zoomAtPoint(d, b);
  }, s.prototype.handleMouseDown = function(r, l) {
    this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), t.mouseAndTouchNormalize(r, this.svg), this.options.dblClickZoomEnabled && t.isDblClick(r, l) ? this.handleDblClick(r) : (this.state = "pan", this.firstEventCTM = this.viewport.getCTM(), this.stateOrigin = o.getEventPoint(r, this.svg).matrixTransform(
      this.firstEventCTM.inverse()
    ));
  }, s.prototype.handleMouseMove = function(r) {
    if (this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), this.state === "pan" && this.options.panEnabled) {
      var l = o.getEventPoint(r, this.svg).matrixTransform(
        this.firstEventCTM.inverse()
      ), d = this.firstEventCTM.translate(
        l.x - this.stateOrigin.x,
        l.y - this.stateOrigin.y
      );
      this.viewport.setCTM(d);
    }
  }, s.prototype.handleMouseUp = function(r) {
    this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), this.state === "pan" && (this.state = "none");
  }, s.prototype.handleTouchStart = function(r, l) {
    if (r.touches.length == 1)
      this.handleMouseDown(r, l);
    else {
      this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), this.firstEventCTM = this.viewport.getCTM();
      var d = o.getTouchPoint(r, this.svg, 0), b = o.getTouchPoint(r, this.svg, 1);
      this.firstDistance = t.calculateDistance(d, b), d.x = (d.x + b.x) / 2, d.y = (d.y + b.y) / 2, this.stateOrigin = d.matrixTransform(this.firstEventCTM.inverse()), this.firstZoomLevel = this.getZoom();
    }
  }, s.prototype.handleTouchMove = function(r) {
    if (r.touches.length == 1)
      this.handleMouseMove(r);
    else {
      if (this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), !this.options.panEnabled && !this.options.zoomEnabled)
        return;
      var l = o.getTouchPoint(r, this.svg, 0), d = o.getTouchPoint(r, this.svg, 1), b = this.svg.createSVGPoint();
      if (b.x = (l.x + d.x) / 2, b.y = (l.y + d.y) / 2, this.state === "pan" && this.options.panEnabled) {
        var k = b.matrixTransform(this.firstEventCTM.inverse()), g = this.firstEventCTM.translate(
          k.x - this.stateOrigin.x,
          k.y - this.stateOrigin.y
        );
        this.viewport.setCTM(g);
      }
      if (this.options.zoomEnabled) {
        var v = t.calculateDistance(l, d), w = v / this.firstDistance, E = this.svg.getScreenCTM().inverse(), m = b.matrixTransform(E);
        this.zoomAtPoint(this.firstZoomLevel * w, m, !0);
      }
    }
  }, s.prototype.handleTouchEnd = function(r) {
    if (r.touches.length == 0)
      this.handleMouseUp(r);
    else if (this.options.preventMouseEventsDefault && (r.preventDefault ? r.preventDefault() : r.returnValue = !1), this.firstEventCTM = this.viewport.getCTM(), r.touches.length == 1)
      this.stateOrigin = o.getEventPoint(r, this.svg).matrixTransform(
        this.firstEventCTM.inverse()
      );
    else {
      var l = o.getTouchPoint(r, this.svg, 0), d = o.getTouchPoint(r, this.svg, 1);
      this.firstDistance = t.calculateDistance(l, d), l.x = (l.x + d.x) / 2, l.y = (l.y + d.y) / 2, this.stateOrigin = l.matrixTransform(this.firstEventCTM.inverse());
    }
  }, s.prototype.fit = function() {
    var r = this.viewport.getViewBox(), l = Math.min(
      this.width / r.width,
      this.height / r.height
    );
    this.zoom(l, !0);
  }, s.prototype.contain = function() {
    var r = this.viewport.getViewBox(), l = Math.max(
      this.width / r.width,
      this.height / r.height
    );
    this.zoom(l, !0);
  }, s.prototype.center = function() {
    var r = this.viewport.getViewBox(), l = (this.width - (r.width + r.x * 2) * this.getZoom()) * 0.5, d = (this.height - (r.height + r.y * 2) * this.getZoom()) * 0.5;
    this.getPublicInstance().pan({ x: l, y: d });
  }, s.prototype.updateBBox = function() {
    this.viewport.simpleViewBoxCache();
  }, s.prototype.pan = function(r) {
    var l = this.viewport.getCTM();
    l.e = r.x, l.f = r.y, this.viewport.setCTM(l);
  }, s.prototype.panBy = function(r) {
    var l = this.viewport.getCTM();
    l.e += r.x, l.f += r.y, this.viewport.setCTM(l);
  }, s.prototype.getPan = function() {
    var r = this.viewport.getState();
    return { x: r.x, y: r.y };
  }, s.prototype.resize = function() {
    var r = o.getBoundingClientRectNormalized(
      this.svg
    );
    this.width = r.width, this.height = r.height;
    var l = this.viewport;
    l.options.width = this.width, l.options.height = this.height, l.processCTM(), this.options.controlIconsEnabled && (this.getPublicInstance().disableControlIcons(), this.getPublicInstance().enableControlIcons());
  }, s.prototype.destroy = function() {
    var r = this;
    this.beforeZoom = null, this.onZoom = null, this.beforePan = null, this.onPan = null, this.onUpdatedCTM = null, this.options.customEventsHandler != null && this.options.customEventsHandler.destroy({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    for (var l in this.eventListeners)
      (this.options.eventsListenerElement || this.svg).removeEventListener(
        l,
        this.eventListeners[l],
        this.options.preventMouseEventsDefault ? u : c
      );
    this.disableMouseWheelZoom(), this.getPublicInstance().disableControlIcons(), h = h.filter(function(d) {
      return d.svg !== r.svg;
    }), delete this.options, delete this.viewport, delete this.publicInstance, delete this.pi, this.getPublicInstance = function() {
      return null;
    };
  }, s.prototype.getPublicInstance = function() {
    var r = this;
    return this.publicInstance || (this.publicInstance = this.pi = {
      // Pan
      enablePan: function() {
        return r.options.panEnabled = !0, r.pi;
      },
      disablePan: function() {
        return r.options.panEnabled = !1, r.pi;
      },
      isPanEnabled: function() {
        return !!r.options.panEnabled;
      },
      pan: function(l) {
        return r.pan(l), r.pi;
      },
      panBy: function(l) {
        return r.panBy(l), r.pi;
      },
      getPan: function() {
        return r.getPan();
      },
      // Pan event
      setBeforePan: function(l) {
        return r.options.beforePan = l === null ? null : t.proxy(l, r.publicInstance), r.pi;
      },
      setOnPan: function(l) {
        return r.options.onPan = l === null ? null : t.proxy(l, r.publicInstance), r.pi;
      },
      // Zoom and Control Icons
      enableZoom: function() {
        return r.options.zoomEnabled = !0, r.pi;
      },
      disableZoom: function() {
        return r.options.zoomEnabled = !1, r.pi;
      },
      isZoomEnabled: function() {
        return !!r.options.zoomEnabled;
      },
      enableControlIcons: function() {
        return r.options.controlIconsEnabled || (r.options.controlIconsEnabled = !0, e.enable(r)), r.pi;
      },
      disableControlIcons: function() {
        return r.options.controlIconsEnabled && (r.options.controlIconsEnabled = !1, e.disable(r)), r.pi;
      },
      isControlIconsEnabled: function() {
        return !!r.options.controlIconsEnabled;
      },
      // Double click zoom
      enableDblClickZoom: function() {
        return r.options.dblClickZoomEnabled = !0, r.pi;
      },
      disableDblClickZoom: function() {
        return r.options.dblClickZoomEnabled = !1, r.pi;
      },
      isDblClickZoomEnabled: function() {
        return !!r.options.dblClickZoomEnabled;
      },
      // Mouse wheel zoom
      enableMouseWheelZoom: function() {
        return r.enableMouseWheelZoom(), r.pi;
      },
      disableMouseWheelZoom: function() {
        return r.disableMouseWheelZoom(), r.pi;
      },
      isMouseWheelZoomEnabled: function() {
        return !!r.options.mouseWheelZoomEnabled;
      },
      // Zoom scale and bounds
      setZoomScaleSensitivity: function(l) {
        return r.options.zoomScaleSensitivity = l, r.pi;
      },
      setMinZoom: function(l) {
        return r.options.minZoom = l, r.pi;
      },
      setMaxZoom: function(l) {
        return r.options.maxZoom = l, r.pi;
      },
      // Zoom event
      setBeforeZoom: function(l) {
        return r.options.beforeZoom = l === null ? null : t.proxy(l, r.publicInstance), r.pi;
      },
      setOnZoom: function(l) {
        return r.options.onZoom = l === null ? null : t.proxy(l, r.publicInstance), r.pi;
      },
      // Zooming
      zoom: function(l) {
        return r.publicZoom(l, !0), r.pi;
      },
      zoomBy: function(l) {
        return r.publicZoom(l, !1), r.pi;
      },
      zoomAtPoint: function(l, d) {
        return r.publicZoomAtPoint(l, d, !0), r.pi;
      },
      zoomAtPointBy: function(l, d) {
        return r.publicZoomAtPoint(l, d, !1), r.pi;
      },
      zoomIn: function() {
        return this.zoomBy(1 + r.options.zoomScaleSensitivity), r.pi;
      },
      zoomOut: function() {
        return this.zoomBy(1 / (1 + r.options.zoomScaleSensitivity)), r.pi;
      },
      getZoom: function() {
        return r.getRelativeZoom();
      },
      // CTM update
      setOnUpdatedCTM: function(l) {
        return r.options.onUpdatedCTM = l === null ? null : t.proxy(l, r.publicInstance), r.pi;
      },
      // Reset
      resetZoom: function() {
        return r.resetZoom(), r.pi;
      },
      resetPan: function() {
        return r.resetPan(), r.pi;
      },
      reset: function() {
        return r.reset(), r.pi;
      },
      // Fit, Contain and Center
      fit: function() {
        return r.fit(), r.pi;
      },
      contain: function() {
        return r.contain(), r.pi;
      },
      center: function() {
        return r.center(), r.pi;
      },
      // Size and Resize
      updateBBox: function() {
        return r.updateBBox(), r.pi;
      },
      resize: function() {
        return r.resize(), r.pi;
      },
      getSizes: function() {
        return {
          width: r.width,
          height: r.height,
          realZoom: r.getZoom(),
          viewBox: r.viewport.getViewBox()
        };
      },
      // Destroy
      destroy: function() {
        return r.destroy(), r.pi;
      }
    }), this.publicInstance;
  };
  var h = [], f = function(r, l) {
    var d = t.getSvg(r);
    if (d === null)
      return null;
    for (var b = h.length - 1; b >= 0; b--)
      if (h[b].svg === d)
        return h[b].instance.getPublicInstance();
    return h.push({
      svg: d,
      instance: new s(d, l)
    }), h[h.length - 1].instance.getPublicInstance();
  };
  return Mt = f, Mt;
}
var ss = is();
const rs = /* @__PURE__ */ es(ss), as = {
  getViewArea() {
    const n = this.getSizes(), e = this.getPan(), t = n.realZoom;
    e.x /= t, e.y /= t;
    const o = {
      width: n.width / t,
      height: n.height / t
    };
    return {
      box: {
        top: -e.y,
        bottom: o.height - e.y,
        left: -e.x,
        right: o.width - e.x
      },
      center: {
        x: o.width / 2 - e.x,
        y: o.height / 2 - e.y
      }
    };
  },
  getViewBox() {
    return this.getViewArea().box;
  },
  setViewBox(n) {
    const e = n.right - n.left, t = n.bottom - n.top, { width: o, height: i } = this.getSizes(), s = e / t, a = o / i, c = s < a ? t * a : e, u = s > a ? e / a : t, h = Math.min(
      o / c,
      i / u
    ), f = this.getRealZoom(), r = this.getZoom(), l = f / r;
    this.zoom(h / l);
    const d = {
      x: (n.left + e / 2) * h,
      y: (n.top + t / 2) * h
    };
    this.pan({
      x: -d.x + c / 2 * h,
      y: -d.y + u / 2 * h
    });
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(n, e, t) {
    const o = Math.max(1e-4, e), i = Math.max(o, t), s = Math.max(Math.min(i, n), o), a = this.getRealZoom(), c = this.getZoom(), u = a / c;
    this.setMinZoom(o / u).setMaxZoom(i / u).zoom(s / u);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    return this._isPanEnabled = !0, this._internalEnablePan(), this;
  },
  disablePan() {
    return this._isPanEnabled = !1, this._internalDisablePan(), this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    return this._isZoomEnabled = !0, this._internalEnableZoom(), this;
  },
  disableZoom() {
    return this._isZoomEnabled = !1, this._internalDisableZoom(), this;
  },
  setPanEnabled(n) {
    return n ? this.enablePan() : this.disablePan(), this;
  },
  setZoomEnabled(n) {
    return n ? (this.enableZoom(), this.enableDblClickZoom()) : (this.disableZoom(), this.disableDblClickZoom()), this;
  }
};
function ls(n, e) {
  var o, i;
  const t = n;
  return t._isPanEnabled = (o = e.panEnabled) != null ? o : !0, t._isZoomEnabled = (i = e == null ? void 0 : e.zoomEnabled) != null ? i : !0, t._internalIsPanEnabled = t.isPanEnabled, t._internalEnablePan = t.enablePan, t._internalDisablePan = t.disablePan, t._internalIsZoomEnabled = t.isZoomEnabled, t._internalEnableZoom = t.enableZoom, t._internalDisableZoom = t.disableZoom, Object.assign(n, as), t;
}
function cs(n, e) {
  var s, a, c, u, h, f;
  const t = (a = (s = e.customEventsHandler) == null ? void 0 : s.init) != null ? a : (r) => {
  }, o = (u = (c = e.customEventsHandler) == null ? void 0 : c.destroy) != null ? u : (r) => {
  }, i = (f = (h = e.customEventsHandler) == null ? void 0 : h.haltEventListeners) != null ? f : [];
  return e.mouseWheelZoomEnabled === void 0 && (e.mouseWheelZoomEnabled = e.zoomEnabled), e.customEventsHandler = {
    init: (r) => {
      ls(r.instance, e), t(r);
    },
    destroy: (r) => o(r),
    haltEventListeners: i
  }, rs(n, e);
}
function us(n, e) {
  const t = j();
  let o = 0;
  const i = [], s = [], a = () => {
    o = 1, i.forEach((f) => f()), i.length = 0;
  }, c = () => {
    o = 2, s.forEach((f) => f()), s.length = 0;
  };
  return je(() => {
    var k, g, v, w, E, m;
    const f = q(n.value, "<svg>"), r = (g = (k = e.customEventsHandler) == null ? void 0 : k.init) != null ? g : (p) => {
    }, l = (w = (v = e.customEventsHandler) == null ? void 0 : v.destroy) != null ? w : (p) => {
    }, d = (m = (E = e.customEventsHandler) == null ? void 0 : E.haltEventListeners) != null ? m : [];
    e.customEventsHandler = {
      init: (p) => {
        t.value = p.instance, r(p), a();
      },
      destroy: (p) => {
        c(), l(p);
      },
      haltEventListeners: d
    };
    const b = () => {
      const p = f.getBoundingClientRect();
      p.width !== 0 && p.height !== 0 ? cs(f, e) : setTimeout(b, 200);
    };
    b();
  }), Xe(() => {
    var f;
    (f = t.value) == null || f.destroy(), t.value = void 0;
  }), { svgPanZoom: t, onSvgPanZoomMounted: (f) => {
    o === 0 ? i.push(f) : o === 1 && f();
  }, onSvgPanZoomUnmounted: (f) => {
    o === 0 || o === 1 ? s.push(f) : f();
  } };
}
const to = Symbol("zoomLevel");
function ds(n, e) {
  const t = O(() => e.scalingObjects ? 1 : 1 / n.value);
  return Me(to, {
    zoomLevel: n,
    scale: t
  }), { scale: t };
}
function de() {
  return q(Ce(to), "zoomLevel");
}
function fs(n) {
  return n instanceof Promise || n && typeof n.then == "function";
}
function hs() {
  let n = null;
  const e = j({
    enabled: !1,
    duration: 300,
    timingFunction: "linear"
  });
  function t(o, i = 300, s = "linear") {
    n && (clearTimeout(n), n = null), e.value = {
      enabled: !0,
      duration: i,
      timingFunction: s
    }, At(() => pe(this, null, function* () {
      const a = o();
      fs(a) && (yield a), n && clearTimeout(n), n = window == null ? void 0 : window.setTimeout(() => {
        e.value.enabled = !1, n = null;
      }, i);
    }));
  }
  return { transitionWhile: t, transitionOption: e };
}
function ps(n) {
  const e = j({}), t = j(!1);
  let o = 1;
  const i = /* @__PURE__ */ new Map();
  return ue(() => {
    if (n.value instanceof Array) {
      const s = /* @__PURE__ */ new Set([]);
      if (e.value = Object.fromEntries(
        n.value.map((a) => {
          let c = a.id;
          return c || (t.value || (t.value = !0, console.warn(
            "[v-network-graph] Please specify the `id` field for the `Path` object. Currently, this works for compatibility, but in the future, the id field will be required."
          )), c = i.get(a), c || (c = "path-" + o++, i.set(a, c))), s.add(c), [c, a];
        })
      ), t.value)
        for (const [a, c] of Array.from(i.entries()))
          s.has(c) || i.delete(a);
    } else
      e.value = n.value;
  }), { objects: e, isInCompatibilityModeForPath: t };
}
function vs(n, e, t, o) {
  if (o) {
    const s = j(o(n[e])), a = (c) => {
      Pe(c, s.value) || (s.value = c), Pe(c, n[e]) || t(`update:${e}`, c);
    };
    return F(() => o(s.value), a), F(() => n[e], (c) => a(o(c))), s.value !== n[e] && t(`update:${e}`, s.value), s;
  }
  const i = j(n[e]);
  return F(
    () => n[e],
    (s) => {
      Pe(s, i.value) || (i.value = s);
    }
  ), F(i, (s) => {
    Pe(s, n[e]) || t(`update:${e}`, s);
  }), i;
}
function Ct(n, e, t, o) {
  const i = Ee(/* @__PURE__ */ new Set());
  return F(
    () => n[e],
    () => {
      const a = n[e].filter((c) => c in t.value);
      Pe(a, Array.from(i)) || (i.clear(), a.forEach(i.add, i));
    },
    { deep: !0, immediate: !0 }
  ), F(i, () => {
    const s = Array.from(i);
    Pe(n[e], s) || o(`update:${e}`, s);
  }), xe(i);
}
const no = Symbol("selection");
function gs(n, e, t) {
  Me(no, {
    selectedNodes: n,
    selectedEdges: e,
    selectedPaths: t
  });
}
function ms() {
  return q(Ce(no), "Selections");
}
const oo = Symbol("layouts");
function bs(n) {
  Me(oo, n);
}
function Kt() {
  return q(Ce(oo), "Layouts");
}
function ys(n, e) {
  for (let t = 0; t < n.length - 1; t++)
    e(n[t], n[t + 1]);
}
function He(n, e) {
  const t = n.indexOf(e);
  t >= 0 && n.splice(t, 1);
}
function ws(n, e, t) {
  const o = n.indexOf(e);
  o < 0 || n.splice(o + 1, 0, t);
}
function Es(n, e) {
  const t = [
    "edges",
    "edge-labels",
    "focusring",
    "nodes",
    "node-labels",
    "paths"
  ];
  return O(() => {
    const o = Ho(n.view.builtInLayerOrder).filter((s) => {
      const a = t.includes(s);
      return a || console.warn(`Layer ${s} is not a built-in layer.`), a;
    }).reverse(), i = [...t];
    return ys(o, (s, a) => {
      He(i, a), ws(i, s, a);
    }), "edge-label" in e || "edges-label" in e || He(i, "edge-labels"), n.node.focusring.visible || He(i, "focusring"), n.node.label.visible === !1 && He(i, "node-labels"), n.path.visible || He(i, "paths"), i;
  });
}
const Cn = () => new Promise((n) => At(n));
function ks(n, e) {
  const t = Math.max(n.width, n.height, e.width, e.height) / 1e4;
  return Math.abs(n.x - e.x) < t && Math.abs(n.y - e.y) < t && Math.abs(n.width - e.width) < t && Math.abs(n.height - e.height) < t;
}
function xs(n, e) {
  return {
    top: n.top + e.top,
    left: n.left + e.left,
    right: n.right + e.right,
    bottom: n.bottom + e.bottom
  };
}
function Ps(n, e) {
  return {
    top: n.top * e,
    left: n.left * e,
    right: n.right * e,
    bottom: n.bottom * e
  };
}
function Ss(n, e) {
  return {
    top: n.top / e,
    left: n.left / e,
    right: n.right / e,
    bottom: n.bottom / e
  };
}
function io(n) {
  return {
    top: n.y,
    left: n.x,
    right: n.x + n.width,
    bottom: n.y + n.height
  };
}
function so(n) {
  return {
    x: n.left,
    y: n.top,
    width: n.right - n.left,
    height: n.bottom - n.top
  };
}
function Ms(n, e) {
  return {
    top: Math.min(n.top, e.top),
    left: Math.min(n.left, e.left),
    right: Math.max(n.right, e.right),
    bottom: Math.max(n.bottom, e.bottom)
  };
}
const Cs = new RegExp("^\\d+$");
function Os(n, e) {
  let t = { top: 0, left: 0, right: 0, bottom: 0 };
  if (typeof n == "string") {
    const o = Ae(n, e.width), i = Ae(n, e.height);
    o === void 0 || i === void 0 ? console.warn("Invalid `fitContentMargin` value.", n) : t = { top: i, left: o, right: o, bottom: i };
  } else if (typeof n == "number") {
    const o = n;
    t = { top: o, left: o, right: o, bottom: o };
  } else {
    if (n.top) {
      const o = Ae(n.top, e.height);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", n.top) : t.top = o;
    }
    if (n.left) {
      const o = Ae(n.left, e.width);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", n.left) : t.left = o;
    }
    if (n.right) {
      const o = Ae(n.right, e.width);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", n.right) : t.right = o;
    }
    if (n.bottom) {
      const o = Ae(n.bottom, e.height);
      o === void 0 ? console.warn("Invalid `fitContentMargin` value.", n.bottom) : t.bottom = o;
    }
  }
  return t;
}
function zs(n, e, t, o, i, s) {
  const a = n.getBBox();
  if (s)
    return _s(a, e, t, i);
  {
    const c = Ts(n);
    return Is(
      a,
      c,
      e,
      t,
      o,
      i
    );
  }
}
function Ae(n, e) {
  if (typeof n == "string") {
    if (n.endsWith("%")) {
      const t = parseInt(n.toString());
      if (Number.isFinite(t))
        return e * (t / 100);
    } else if (n.endsWith("px") || Cs.test(n)) {
      const t = parseInt(n.toString());
      if (Number.isFinite(t))
        return t;
    }
  } else if (typeof n == "number")
    return n;
}
function Ts(n) {
  return Array.from(n.querySelectorAll(".v-ng-graph-objects")).map(
    (t) => t.getBBox()
  ).reduce(
    (t, o, i) => {
      if (i === 0) return o;
      const s = Math.min(t.x, o.x), a = Math.min(t.y, o.y);
      return {
        x: s,
        y: a,
        width: Math.max(t.x + t.width - s, o.x + o.width - s),
        height: Math.max(t.y + t.height - a, o.y + o.height - a)
      };
    },
    { x: 0, y: 0, width: 0, height: 0 }
  );
}
function _s(n, e, t, o) {
  if (Object.keys(t).length <= 1)
    return;
  const i = ro(n, e, o);
  if (i > 0) {
    const s = io(n);
    return {
      zoom: i,
      pos: ao(s, i, e, o)
    };
  } else
    return;
}
function Is(n, e, t, o, i, s) {
  if (Object.keys(o).length <= 1)
    return;
  const a = hi(o), c = {
    top: (a.top - e.y) * i,
    left: (a.left - e.x) * i,
    right: (e.x + e.width - a.right) * i,
    bottom: (e.y + e.height - a.bottom) * i
  };
  let u = ro(n, t, s);
  if (u === 0)
    return;
  const h = it(t, xs(s, c));
  if (h.width <= 0 || h.height <= 0)
    return;
  const f = io(n), r = it(t, s), l = ks(n, e);
  let d = 0, b = 0, k = { top: 0, left: 0, right: 0, bottom: 0 };
  do {
    b = u;
    const g = Ss(c, u), v = {
      top: a.top - g.top,
      left: a.left - g.left,
      right: a.right + g.right,
      bottom: a.bottom + g.bottom
    };
    k = l ? v : Ms(f, v);
    const w = so(k), m = [r.width / w.width, r.height / w.height].filter((p) => p > 0);
    if (m.length === 0)
      return;
    u = Math.min(...m), d++;
  } while (Math.abs(b - u) > 1e-6 && d < 10);
  return {
    zoom: u,
    pos: ao(k, u, t, s)
  };
}
function ro(n, e, t) {
  if (n.width === 0 || n.height === 0) return 0;
  const o = it(e, t);
  if (o.width <= 0 || o.height <= 0)
    return 0;
  const i = [o.width / n.width, o.height / n.height];
  return Math.min(...i);
}
function ao(n, e, t, o) {
  const i = it(t, o), s = so(Ps(n, e)), a = (i.width - s.width) / 2, c = (i.height - s.height) / 2, u = s.x - o.left, h = s.y - o.top;
  return {
    x: -u + a,
    y: -h + c
  };
}
function it(n, e) {
  const t = e.left + e.right, o = e.top + e.bottom;
  return {
    width: n.width - t,
    height: n.height - o
  };
}
const Ls = ["x", "y", "width", "height", "fill", "stroke", "stroke-width", "stroke-dasharray"], $s = /* @__PURE__ */ U({
  __name: "VSelectionBox",
  props: {
    box: {},
    config: {}
  },
  setup(n) {
    return (e, t) => (S(), I("rect", {
      class: "v-ng-selection-box",
      x: Math.round(e.box.pos.x),
      y: Math.round(e.box.pos.y),
      width: Math.ceil(e.box.size.width),
      height: Math.ceil(e.box.size.height),
      fill: e.config.color,
      stroke: e.config.strokeColor,
      "stroke-width": e.config.strokeWidth,
      "stroke-dasharray": e.config.strokeDasharray
    }, null, 8, Ls));
  }
}), As = ["points", "fill"], Zs = /* @__PURE__ */ U({
  __name: "VMarkerHeadArrow",
  props: {
    width: {},
    height: {},
    refX: {},
    color: {},
    isSource: { type: Boolean },
    units: {}
  },
  setup(n) {
    const e = n, t = O(() => {
      const o = e.width, i = e.height;
      return e.isSource ? `${o} ${i}, 0 ${i / 2}, ${o} 0` : `0 0, ${o} ${i / 2}, 0 ${i}`;
    });
    return (o, i) => (S(), I("polygon", {
      points: t.value,
      fill: o.color
    }, null, 8, As));
  }
}), Ds = ["points", "stroke-width", "stroke"], Ns = /* @__PURE__ */ U({
  __name: "VMarkerHeadAngle",
  props: {
    width: {},
    height: {},
    refX: {},
    color: {},
    isSource: { type: Boolean },
    units: {}
  },
  setup(n) {
    const e = n, t = O(() => e.units === "strokeWidth" ? 1 : Math.min(e.width, e.height) / 5), o = O(() => {
      const i = t.value / 2, s = e.width, a = e.height;
      return e.isSource ? `${s - i} ${a - i}, ${i} ${a / 2}, ${s - i} ${i}` : `${i} ${i}, ${s - i} ${a / 2}, ${i} ${a - i}`;
    });
    return (i, s) => (S(), I("polyline", {
      points: o.value,
      fill: "none",
      "stroke-width": t.value,
      stroke: i.color,
      "stroke-linecap": "round",
      "stroke-linejoin": "round"
    }, null, 8, Ds));
  }
}), js = ["fill", "cx", "cy", "rx", "ry"], Bs = /* @__PURE__ */ U({
  __name: "VMarkerHeadCircle",
  props: {
    width: {},
    height: {},
    refX: {},
    color: {},
    isSource: { type: Boolean },
    units: {}
  },
  setup(n) {
    return (e, t) => (S(), I("ellipse", {
      fill: e.color,
      cx: e.width / 2,
      cy: e.height / 2,
      rx: e.width / 2,
      ry: e.height / 2
    }, null, 8, js));
  }
}), Rs = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"], Vs = /* @__PURE__ */ U({
  __name: "VMarkerHead",
  props: {
    id: {},
    marker: {},
    scale: {}
  },
  setup(n) {
    const e = {
      arrow: Zs,
      angle: Ns,
      circle: Bs
    }, t = n, o = O(
      () => t.marker.width * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), i = O(
      () => t.marker.height * (t.marker.units === "strokeWidth" ? 1 : t.scale)
    ), s = O(() => {
      const c = t.marker.margin * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? o.value + c : -c;
    }), a = O(() => {
      const c = t.marker.offset * (t.marker.units === "strokeWidth" ? 1 : t.scale);
      return t.marker.isSource ? c : -c;
    });
    return (c, u) => c.marker.type !== "none" && c.marker.type !== "custom" ? (S(), I("marker", {
      key: 0,
      id: c.id,
      markerWidth: o.value,
      markerHeight: i.value,
      refX: s.value,
      refY: i.value / 2 + a.value,
      orient: "auto",
      markerUnits: c.marker.units,
      class: "v-ng-marker"
    }, [
      (S(), W(_n(e[c.marker.type]), {
        width: o.value,
        height: i.value,
        refX: s.value,
        color: c.marker.color,
        "is-source": c.marker.isSource,
        units: c.marker.units
      }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
    ], 8, Rs)) : ae("", !0);
  }
}), Ws = {
  class: "v-ng-background-grid",
  "shape-rendering": "crispEdges"
}, Hs = ["d"], Us = ["d"], Fs = ["d"], qs = ["d"], Xs = /* @__PURE__ */ U({
  __name: "VBackgroundGrid",
  setup(n) {
    const { container: e, svgPanZoom: t } = Nt(), { zoomLevel: o } = de(), i = Ji(), s = Ko(), a = j({ x: 0, y: 0 }), c = j({ width: 500, height: 500 });
    je(() => {
      var b;
      const l = (b = t.value) == null ? void 0 : b.getPan();
      l && (a.value = {
        x: -l.x,
        y: -l.y
      });
      const d = e.value.getBoundingClientRect();
      c.value = {
        width: d.width,
        height: d.height
      };
    }), i.on("view:resize", (l) => {
      c.value = { width: l.width, height: l.height };
    }), i.on("view:pan", (l) => {
      a.value = { x: -l.x, y: -l.y };
    }), i.on("view:zoom", () => {
      var d;
      const l = (d = t.value) == null ? void 0 : d.getPan();
      l && (a.value = { x: -l.x, y: -l.y });
    });
    const u = j([]), h = j([]), f = j([]), r = j([]);
    return ue(() => {
      const l = [], d = [], b = [], k = [], g = 1 / o.value, v = s.grid.interval, w = a.value.x * g, E = a.value.y * g, m = Math.floor(c.value.width / v + 1) * v, p = Math.floor(c.value.height / v + 1) * v, y = (a.value.x + m) * g, x = (a.value.y + p) * g, z = s.grid.thickIncrements, L = s.grid.line.dasharray, C = s.grid.thick.dasharray;
      let T = {
        stroke: s.grid.thick.color,
        "stroke-width": s.grid.thick.width,
        "stroke-dasharray": C,
        "stroke-dashoffset": C ? w / g : void 0
      }, $ = {
        stroke: s.grid.line.color,
        "stroke-width": s.grid.line.width,
        "stroke-dasharray": L,
        "stroke-dashoffset": L ? w / g : void 0
      };
      const N = (a.value.x + m) * g;
      for (let B = E; B <= x; B += v) {
        const H = Math.floor(B / v);
        z && H % z === 0 ? l.push([H, H * v, w, N, T]) : b.push([H, H * v, w, N, $]);
      }
      T = oe({}, T), T["stroke-dashoffset"] = C ? E / g : void 0, $ = oe({}, $), $["stroke-dashoffset"] = L ? E / g : void 0;
      const G = (a.value.y + p) * g;
      for (let B = w; B <= y; B += v) {
        const H = Math.floor(B / v);
        z && H % z === 0 ? d.push([H, H * v, E, G, T]) : k.push([H, H * v, E, G, $]);
      }
      h.value = l, u.value = d, r.value = b, f.value = k;
    }), (l, d) => (S(), I("g", Ws, [
      (S(!0), I(X, null, Q(r.value, ([b, k, g, v, w]) => (S(), I("path", ne({
        key: `nv${b}`,
        d: `M ${g} ${k} L ${v} ${k}`,
        ref_for: !0
      }, w, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Hs))), 128)),
      (S(!0), I(X, null, Q(f.value, ([b, k, g, v, w]) => (S(), I("path", ne({
        key: `nh${b}`,
        d: `M ${k} ${g} L ${k} ${v}`,
        ref_for: !0
      }, w, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Us))), 128)),
      (S(!0), I(X, null, Q(h.value, ([b, k, g, v, w]) => (S(), I("path", ne({
        key: `tv${b}`,
        d: `M ${g} ${k} L ${v} ${k}`,
        ref_for: !0
      }, w, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, Fs))), 128)),
      (S(!0), I(X, null, Q(u.value, ([b, k, g, v, w]) => (S(), I("path", ne({
        key: `th${b}`,
        d: `M ${k} ${g} L ${k} ${v}`,
        ref_for: !0
      }, w, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, qs))), 128))
    ]));
  }
}), Gs = /* @__PURE__ */ U({
  __name: "VBackgroundViewport",
  setup(n) {
    const { viewport: e } = Nt(), t = j(), o = (s, a, c) => {
      s.forEach((u) => {
        var h;
        return a.setAttribute(u, (h = c.getAttribute(u)) != null ? h : "");
      });
    }, i = new MutationObserver((s) => {
      if (!t.value) return;
      const a = s.map((c) => {
        var u;
        return (u = c.attributeName) != null ? u : "";
      }).filter(Boolean);
      o(a, t.value, e.value);
    });
    return je(() => {
      const s = ["transform", "style"];
      i.observe(e.value, {
        attributes: !0,
        attributeFilter: s
      }), t.value && o(s, t.value, e.value);
    }), Xe(() => {
      i.disconnect();
    }), (s, a) => (S(), I("g", {
      ref_key: "background",
      ref: t,
      class: "v-ng-background-viewport"
    }, [
      K(s.$slots, "default")
    ], 512));
  }
}), Ks = ["d", "stroke-width"], Ys = /* @__PURE__ */ U({
  __name: "VEdgeBackground",
  props: {
    id: {},
    state: {},
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(n) {
    const e = n, { scale: t } = de(), o = ct(), {
      handleEdgePointerDownEvent: i,
      handleEdgePointerOverEvent: s,
      handleEdgePointerOutEvent: a,
      handleEdgeClickEvent: c,
      handleEdgeDoubleClickEvent: u,
      handleEdgeContextMenu: h
    } = Ye(), f = O(() => {
      const l = e.state.position;
      if (e.state.loop) {
        const { radius: d, isLargeArc: b, isClockwise: k } = e.state.loop, [g, v] = d, w = b ? 1 : 0, E = k ? 1 : 0;
        return `M ${l.p1.x} ${l.p1.y} A ${g} ${v} 0 ${w} ${E} ${l.p2.x} ${l.p2.y}`;
      } else {
        if (o.type === "straight" || !e.state.curve)
          return `M ${l.p1.x} ${l.p1.y} L ${l.p2.x} ${l.p2.y}`;
        {
          const d = [...e.state.curve.control, { x: l.p2.x, y: l.p2.y }], b = [];
          return b.push(`M ${l.p1.x} ${l.p1.y}`), Dt(d, 2).forEach(([k, g]) => b.push(`Q ${k.x} ${k.y} ${g.x} ${g.y}`)), b.join(" ");
        }
      }
    }), r = O(() => (e.state.line.stroke.width + 10) * t.value);
    return (l, d) => (S(), I("path", {
      class: ce({ "v-ng-line-background": !0, selectable: l.state.selectable }),
      d: f.value,
      stroke: "transparent",
      "stroke-width": r.value,
      fill: "none",
      onPointerdown: d[0] || (d[0] = ve((b) => M(i)(l.id, b), ["stop"])),
      onPointerenterPassive: d[1] || (d[1] = (b) => M(s)(l.id, b)),
      onPointerleavePassive: d[2] || (d[2] = (b) => M(a)(l.id, b)),
      onClick: d[3] || (d[3] = ve((b) => M(c)(l.id, b), ["stop"])),
      onDblclick: d[4] || (d[4] = ve((b) => M(u)(l.id, b), ["stop"])),
      onContextmenu: d[5] || (d[5] = (b) => M(h)(l.id, b))
    }, null, 42, Ks));
  }
}), Qs = /* @__PURE__ */ U({
  __name: "VEdgeBackgrounds",
  setup(n) {
    const { edgeStates: e, edgeGroupStates: t, layouts: o } = me();
    return (i, s) => (S(!0), I(X, null, Q(M(t).edgeGroups, ({ summarize: a, edges: c }) => (S(), I(X, null, [
      a ? ae("", !0) : (S(!0), I(X, { key: 0 }, Q(c, (u, h) => (S(), W(Ys, {
        key: h,
        id: h,
        state: M(e)[h],
        "source-pos": M(o).nodes[u.source],
        "target-pos": M(o).nodes[u.target]
      }, null, 8, ["id", "state", "source-pos", "target-pos"]))), 128))
    ], 64))), 256));
  }
}), Js = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], lo = /* @__PURE__ */ U({
  __name: "VLine",
  props: {
    p1: {},
    p2: {},
    config: {}
  },
  setup(n) {
    const e = n, { scale: t } = de(), o = O(() => e.config.width * t.value), i = O(() => Ke(e.config.dasharray, t.value)), s = O(() => {
      const a = e.config.animate ? rt(e.config.dasharray) * e.config.animationSpeed * t.value : !1;
      return a ? { "--animation-speed": a } : void 0;
    });
    return (a, c) => (S(), I("path", {
      class: ce({ "v-ng-line": !0, animate: a.config.animate }),
      d: `M ${a.p1.x} ${a.p1.y} L ${a.p2.x} ${a.p2.y}`,
      stroke: a.config.color,
      "stroke-width": o.value,
      "stroke-dasharray": i.value,
      "stroke-linecap": a.config.linecap,
      style: Ge(s.value)
    }, null, 14, Js));
  }
}), er = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"], tr = /* @__PURE__ */ U({
  __name: "VArc",
  props: {
    p1: {},
    p2: {},
    radius: {},
    isLargeArc: { type: Boolean },
    isClockwise: { type: Boolean },
    config: {}
  },
  setup(n) {
    const e = n, { scale: t } = de(), o = O(() => e.config.width * t.value), i = O(() => Ke(e.config.dasharray, t.value)), s = O(() => {
      const c = e.config.animate ? rt(e.config.dasharray) * e.config.animationSpeed * t.value : !1;
      return c ? { "--animation-speed": c } : void 0;
    }), a = O(() => {
      const { p1: c, p2: u, radius: h, isLargeArc: f, isClockwise: r } = e, [l, d] = h, b = f ? 1 : 0, k = r ? 1 : 0;
      return `M ${c.x} ${c.y} A ${l} ${d} 0 ${b} ${k} ${u.x} ${u.y}`;
    });
    return (c, u) => (S(), I("path", {
      class: ce({ "v-ng-line": !0, animate: c.config.animate }),
      d: a.value,
      stroke: c.config.color,
      "stroke-width": o.value,
      "stroke-dasharray": i.value,
      "stroke-linecap": c.config.linecap,
      style: Ge(s.value),
      fill: "none"
    }, null, 14, er));
  }
}), nr = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"], or = /* @__PURE__ */ U({
  __name: "VEdgeCurved",
  props: {
    state: {},
    config: {},
    markerStart: { default: void 0 },
    markerEnd: { default: void 0 }
  },
  setup(n) {
    const e = n, { scale: t } = de(), o = O(() => {
      var f, r;
      const c = e.state.position, u = [...(r = (f = e.state.curve) == null ? void 0 : f.control) != null ? r : [], { x: c.p2.x, y: c.p2.y }], h = [];
      return h.push(`M ${c.p1.x} ${c.p1.y}`), Dt(u, 2).forEach(([l, d]) => h.push(`Q ${l.x} ${l.y} ${d.x} ${d.y}`)), h.join(" ");
    }), i = O(() => e.config.width * t.value), s = O(() => Ke(e.config.dasharray, t.value)), a = O(() => {
      const c = e.config.animate ? rt(e.config.dasharray) * e.config.animationSpeed * t.value : !1;
      return c ? { "--animation-speed": c } : void 0;
    });
    return (c, u) => (S(), I("path", {
      class: ce({ "v-ng-line": !0, animate: c.config.animate }),
      d: o.value,
      fill: "none",
      stroke: c.config.color,
      "stroke-width": i.value,
      "stroke-dasharray": s.value,
      "stroke-linecap": c.config.linecap,
      style: Ge(a.value),
      "marker-start": c.markerStart,
      "marker-end": c.markerEnd
    }, null, 14, nr));
  }
}), ir = /* @__PURE__ */ U({
  __name: "VEdge",
  props: {
    id: {},
    state: {},
    sourcePos: { default: void 0 },
    targetPos: { default: void 0 }
  },
  setup(n) {
    const e = ct();
    return (t, o) => t.state.loop ? (S(), W(tr, ne({ key: 0 }, t.state.position, {
      radius: t.state.loop.radius,
      "is-large-arc": t.state.loop.isLargeArc,
      "is-clockwise": t.state.loop.isClockwise,
      class: [{ selectable: t.state.selectable, hover: t.state.hovered, selected: t.state.selected }, "v-ng-edge"],
      config: t.state.line.stroke,
      "marker-start": t.state.sourceMarkerId ? `url('#${t.state.sourceMarkerId}')` : void 0,
      "marker-end": t.state.targetMarkerId ? `url('#${t.state.targetMarkerId}')` : void 0
    }), null, 16, ["radius", "is-large-arc", "is-clockwise", "class", "config", "marker-start", "marker-end"])) : M(e).type == "straight" || !t.state.curve ? (S(), W(lo, ne({
      key: 1,
      "data-edge-id": t.id
    }, t.state.position, {
      class: [{ selectable: t.state.selectable, hover: t.state.hovered, selected: t.state.selected }, "v-ng-edge"],
      config: t.state.line.stroke,
      "marker-start": t.state.sourceMarkerId ? `url('#${t.state.sourceMarkerId}')` : void 0,
      "marker-end": t.state.targetMarkerId ? `url('#${t.state.targetMarkerId}')` : void 0
    }), null, 16, ["data-edge-id", "class", "config", "marker-start", "marker-end"])) : (S(), W(or, {
      key: 2,
      "data-edge-id": t.id,
      class: ce([{ selectable: t.state.selectable, hover: t.state.hovered, selected: t.state.selected }, "v-ng-edge"]),
      state: t.state,
      config: t.state.line.stroke,
      "marker-start": t.state.sourceMarkerId ? `url('#${t.state.sourceMarkerId}')` : void 0,
      "marker-end": t.state.targetMarkerId ? `url('#${t.state.targetMarkerId}')` : void 0
    }, null, 8, ["data-edge-id", "class", "state", "config", "marker-start", "marker-end"]));
  }
}), sr = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"], rr = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"], ft = /* @__PURE__ */ U({
  __name: "VShape",
  props: {
    baseX: { default: 0 },
    baseY: { default: 0 },
    config: {}
  },
  setup(n) {
    const e = n, { scale: t } = de(), o = j(e.baseX), i = j(e.baseY), s = j(0), a = j("#000000"), c = j(void 0), u = j(0), h = j(0), f = j(0), r = j(0);
    return ue(() => {
      var d;
      const l = t.value;
      s.value = e.config.strokeWidth * l, a.value = (d = e.config.strokeColor) != null ? d : "none", c.value = Ke(e.config.strokeDasharray, l), e.config.type === "circle" ? (o.value = e.baseX, i.value = e.baseY, u.value = e.config.radius * l) : (h.value = e.config.width * l, f.value = e.config.height * l, r.value = e.config.borderRadius * l, o.value = e.baseX - h.value / 2, i.value = e.baseY - f.value / 2);
    }), (l, d) => l.config.type === "circle" ? (S(), I("circle", {
      key: 0,
      class: "v-ng-shape-circle",
      cx: o.value,
      cy: i.value,
      r: u.value,
      fill: l.config.color,
      stroke: a.value,
      "stroke-width": s.value,
      "stroke-dasharray": c.value
    }, null, 8, sr)) : (S(), I("rect", {
      key: 1,
      class: "v-ng-shape-rect",
      x: o.value,
      y: i.value,
      width: h.value,
      height: f.value,
      rx: r.value,
      ry: r.value,
      fill: l.config.color,
      stroke: a.value,
      "stroke-width": s.value,
      "stroke-dasharray": c.value
    }, null, 8, rr));
  }
}), ar = ["rx", "ry", "fill", "transform"], lr = ["x", "y", "dominant-baseline", "font-family", "font-size", "fill"], cr = ["x", "dy", "dominant-baseline"], ht = /* @__PURE__ */ U({
  __name: "VLabelText",
  props: {
    text: {},
    x: { default: 0 },
    y: { default: 0 },
    dominantBaseline: { default: "central" },
    config: {}
  },
  setup(n) {
    const e = n, t = No(), { scale: o } = de(), i = O(() => {
      var g, v;
      return (v = (g = e.text) == null ? void 0 : g.toString().split(/\r?\n/)) != null ? v : "";
    }), s = O(() => {
      var g;
      return (g = t["font-size"]) != null ? g : e.config.fontSize * o.value;
    }), a = O(() => s.value * e.config.lineHeight), c = O(() => {
      const g = e.dominantBaseline;
      return g === "hanging" ? 0 : g === "central" ? -(a.value * (i.value.length - 1)) / 2 : -a.value * (i.value.length - 1);
    }), u = j(), h = j(""), f = Ee({ x: 0, y: 0, width: 0, height: 0 }), r = O(() => {
      var m, p;
      const g = e.config.background;
      if (!g) return f;
      let v, w;
      g.padding instanceof Object ? (v = g.padding.vertical, w = g.padding.horizontal) : (v = (m = g.padding) != null ? m : 0, w = (p = g.padding) != null ? p : 0);
      const E = a.value - s.value;
      return {
        x: f.x - w * o.value,
        y: f.y - v * o.value - E / 2,
        width: f.width + w * 2 * o.value,
        height: f.height + v * 2 * o.value + E
      };
    });
    let l;
    const d = () => {
      e.config.background && e.config.background.visible ? !l && u.value && (l = k(u.value, f, h)) : (l == null || l.disconnect(), l = void 0);
    };
    je(() => d()), F(
      () => e.config.background && e.config.background.visible,
      (g, v) => {
        g != v && d();
      }
    ), Xe(() => {
      l == null || l.disconnect(), l = void 0;
    });
    function b(g, v, w) {
      var m;
      const E = g.getBBox();
      v.x = E.x, v.y = E.y, v.width = E.width, v.height = E.height, w.value = (m = g.getAttribute("transform")) != null ? m : void 0;
    }
    function k(g, v, w) {
      const E = new MutationObserver(() => {
        b(g, v, w);
      });
      return E.observe(g, {
        attributes: !0,
        attributeFilter: ["x", "y", "transform", "font-size"]
      }), b(g, v, w), E;
    }
    return (g, v) => {
      var w, E, m, p, y, x;
      return S(), I(X, null, [
        g.config.background && g.config.background.visible ? (S(), I("rect", ne({
          key: 0,
          class: "v-ng-text-background"
        }, r.value, {
          rx: ((E = (w = g.config.background) == null ? void 0 : w.borderRadius) != null ? E : 0) * M(o),
          ry: ((p = (m = g.config.background) == null ? void 0 : m.borderRadius) != null ? p : 0) * M(o),
          fill: (x = (y = g.config.background) == null ? void 0 : y.color) != null ? x : "#ffffff",
          transform: h.value
        }), null, 16, ar)) : ae("", !0),
        In("text", ne({
          ref_key: "element",
          ref: u,
          class: "v-ng-text"
        }, g.$attrs, {
          x: g.x,
          y: g.y,
          "dominant-baseline": g.dominantBaseline,
          "font-family": g.$attrs["font-family"] ? `${g.$attrs["font-family"]}` : g.config.fontFamily,
          "font-size": s.value,
          fill: g.$attrs.fill ? `${g.$attrs.fill}` : g.config.color
        }), [
          i.value.length <= 1 ? (S(), I(X, { key: 0 }, [
            jo(rn(g.text), 1)
          ], 64)) : (S(!0), I(X, { key: 1 }, Q(i.value, (z, L) => (S(), I("tspan", {
            key: L,
            x: g.x,
            dy: L == 0 ? c.value : a.value,
            "dominant-baseline": g.dominantBaseline
          }, rn(z), 9, cr))), 128))
        ], 16, lr)
      ], 64);
    };
  }
}), ur = /* @__PURE__ */ U({
  __name: "VEdgeSummarized",
  props: {
    edges: {},
    layouts: {}
  },
  setup(n) {
    const e = n, t = ct(), {
      handleEdgesPointerDownEvent: o,
      handleEdgesPointerOverEvent: i,
      handleEdgesPointerOutEvent: s,
      handleEdgesClickEvent: a,
      handleEdgesDoubleClickEvent: c,
      handleEdgesContextMenu: u
    } = Ye(), { edgeStates: h } = me(), f = j({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 } }), r = j({ x: 0, y: 0 });
    ue(() => {
      const E = Object.keys(e.edges).find((m) => m in h);
      E && (f.value = h[E].position, r.value = {
        x: (f.value.p1.x + f.value.p2.x) / 2,
        y: (f.value.p1.y + f.value.p2.y) / 2
      });
    });
    const l = O(() => Object.keys(e.edges)), d = O(() => _.values(t.summarized.label, e.edges)), b = O(() => _.values(t.summarized.shape, e.edges)), k = O(() => _.values(t.summarized.stroke, e.edges)), g = O(() => l.value.some((E) => h[E].hovered)), v = O(() => l.value.some((E) => h[E].selectable)), w = O(() => l.value.some((E) => h[E].selected));
    return (E, m) => (S(), I("g", {
      class: ce({ "v-ng-line-summarized": !0, hovered: g.value, selectable: v.value, selected: w.value }),
      onPointerdown: m[0] || (m[0] = ve((p) => M(o)(l.value, p), ["stop"])),
      onPointerenterPassive: m[1] || (m[1] = (p) => M(i)(l.value, p)),
      onPointerleavePassive: m[2] || (m[2] = (p) => M(s)(l.value, p)),
      onClick: m[3] || (m[3] = ve((p) => M(a)(l.value, p), ["stop"])),
      onDblclick: m[4] || (m[4] = ve((p) => M(c)(l.value, p), ["stop"])),
      onContextmenu: m[5] || (m[5] = (p) => M(u)(l.value, p))
    }, [
      Ie(lo, ne(f.value, {
        config: k.value,
        "data-edge-id": l.value[0]
      }), null, 16, ["config", "data-edge-id"]),
      Ie(ft, {
        "base-x": r.value.x,
        "base-y": r.value.y,
        config: b.value
      }, null, 8, ["base-x", "base-y", "config"]),
      Ie(ht, {
        text: Object.keys(E.edges).length.toString(),
        x: r.value.x,
        y: r.value.y,
        config: d.value,
        "text-anchor": "middle",
        "dominant-baseline": "central"
      }, null, 8, ["text", "x", "y", "config"])
    ], 34));
  }
}), dr = { class: "v-ng-edge-overlay" }, On = /* @__PURE__ */ U({
  __name: "VEdgeOverlay",
  props: {
    edgeId: { default: void 0 },
    edge: { default: void 0 },
    edges: { default: () => ({}) },
    state: {},
    isSummarized: { type: Boolean }
  },
  setup(n) {
    const e = n, { svg: t } = Nt(), { scale: o } = de(), i = ct();
    function s() {
      return e.isSummarized ? _.values(i.summarized.stroke, e.edges) : e.state.line.stroke;
    }
    function a(f) {
      return { source: f.p1, target: f.p2 };
    }
    function c(f) {
      if (f.curve)
        return f.curve.center;
      {
        const r = f.origin.p1, l = f.origin.p2;
        return {
          x: (r.x + l.x) / 2,
          y: (r.y + l.y) / 2
        };
      }
    }
    function u() {
      var l;
      if (!t.value) return 0;
      const f = (l = e.edgeId) != null ? l : Object.keys(e.edges)[0], r = t.value.querySelector(`path[data-edge-id="${f}"]`);
      return r ? r.getTotalLength() : 0;
    }
    function h(f) {
      var b;
      if (!t.value || !isFinite(f)) return e.state.position.p1;
      e.state;
      const r = (b = e.edgeId) != null ? b : Object.keys(e.edges)[0], l = t.value.querySelector(`path[data-edge-id="${r}"]`);
      if (!l) return e.state.position.p1;
      const d = l.getPointAtLength(f);
      return { x: d.x, y: d.y };
    }
    return (f, r) => (S(), I("g", dr, [
      f.isSummarized ? K(f.$slots, "default", {
        key: 0,
        edges: f.edges,
        isSummarized: f.isSummarized,
        stroke: s(),
        position: a(f.state.origin),
        center: c(f.state),
        hovered: f.state.hovered,
        selected: f.state.selected,
        scale: M(o),
        length: u(),
        pointAtLength: h
      }) : K(f.$slots, "default", {
        key: 1,
        edgeId: f.edgeId,
        edge: f.edge,
        edges: { [f.edgeId]: f.edge },
        isSummarized: f.isSummarized,
        stroke: s(),
        position: a(f.state.origin),
        center: c(f.state),
        hovered: f.state.hovered,
        selected: f.state.selected,
        scale: M(o),
        length: u(),
        pointAtLength: h
      })
    ]));
  }
}), fr = /* @__PURE__ */ U({
  __name: "VEdgeGroups",
  props: {
    hasEdgeOverlaySlot: { type: Boolean }
  },
  setup(n) {
    const { edgeStates: e, edgeZOrderedList: t, layouts: o } = me();
    return (i, s) => (S(!0), I(X, null, Q(M(t), (a) => (S(), I(X, null, [
      M(Ci)(a) ? (S(), I(X, { key: 0 }, [
        (S(), W(ur, {
          key: a.key,
          edges: a.group.edges,
          layouts: M(o).nodes
        }, null, 8, ["edges", "layouts"])),
        i.hasEdgeOverlaySlot ? (S(), W(On, {
          key: a.key,
          edges: a.group.edges,
          state: M(e)[Object.keys(a.group.edges)[0]],
          "is-summarized": !0
        }, {
          default: te((c) => [
            K(i.$slots, "default", ne({ ref_for: !0 }, c))
          ]),
          _: 2
        }, 1032, ["edges", "state"])) : ae("", !0)
      ], 64)) : (S(), I(X, { key: 1 }, [
        (S(), W(ir, {
          id: a.key,
          key: a.key,
          state: M(e)[a.key],
          "source-pos": M(o).nodes[a.edge.source],
          "target-pos": M(o).nodes[a.edge.target]
        }, null, 8, ["id", "state", "source-pos", "target-pos"])),
        i.hasEdgeOverlaySlot ? (S(), W(On, {
          key: a.key,
          "edge-id": a.key,
          edge: a.edge,
          state: M(e)[a.key],
          "is-summarized": !1
        }, {
          default: te((c) => [
            K(i.$slots, "default", ne({ ref_for: !0 }, c))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"])) : ae("", !0)
      ], 64))
    ], 64))), 256));
  }
}), hr = { class: "v-ng-layer-edges v-ng-graph-objects" }, pr = /* @__PURE__ */ U({
  __name: "VEdgesLayer",
  setup(n) {
    const e = st(), t = O(() => "edge-overlay" in e);
    return (o, i) => (S(), I("g", hr, [
      Ie(Qs),
      Ie(fr, { "has-edge-overlay-slot": t.value }, Zt({ _: 2 }, [
        t.value ? {
          name: "default",
          fn: te((s) => [
            K(o.$slots, "edge-overlay", Ot(zt(s)))
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["has-edge-overlay-slot"])
    ]));
  }
}), vr = /* @__PURE__ */ U({
  __name: "VEdgeLabelPlace",
  props: {
    edgeId: {},
    edge: {},
    state: {}
  },
  setup(n) {
    const e = n, { scale: t } = de(), o = O(() => Fn(
      e.state.labelPosition,
      e.state.line.stroke,
      e.state.label.margin,
      e.state.label.padding,
      t.value
    ));
    return (i, s) => i.state.loop ? ae("", !0) : K(i.$slots, "default", {
      key: 0,
      edgeId: i.edgeId,
      edge: i.edge,
      config: i.state.label,
      area: o.value,
      hovered: i.state.hovered,
      selected: i.state.selected,
      scale: M(t)
    });
  }
}), gr = /* @__PURE__ */ U({
  __name: "VEdgeLabelsPlace",
  props: {
    edges: {},
    state: {},
    summarizeState: {}
  },
  setup(n) {
    const e = n, { scale: t } = de(), o = O(() => {
      var i, s;
      return Fn(
        e.state.labelPosition,
        (s = (i = e.summarizeState) == null ? void 0 : i.stroke) != null ? s : e.state.line.stroke,
        e.state.label.margin,
        e.state.label.padding,
        t.value
      );
    });
    return (i, s) => i.state.loop ? ae("", !0) : K(i.$slots, "default", {
      key: 0,
      edges: i.edges,
      config: i.state.label,
      area: o.value,
      hovered: i.state.hovered,
      selected: i.state.selected,
      scale: M(t)
    });
  }
}), mr = { class: "v-ng-edge-labels" }, br = /* @__PURE__ */ U({
  __name: "VEdgeLabels",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(n) {
    const { edgeStates: e, edgeGroupStates: t, summarizedEdgeStates: o } = me(), i = O(() => {
      const a = {}, c = {};
      return Object.entries(t.edgeGroups).forEach(([u, h]) => {
        Object.keys(h.edges).length > 0 && (h.summarize ? c[u] = h : a[u] = h);
      }), { individual: a, summarized: c };
    });
    function s(a) {
      return Object.keys(a.edges)[0];
    }
    return (a, c) => (S(), I("g", mr, [
      a.enableEdgeLabel ? (S(!0), I(X, { key: 0 }, Q(i.value.individual, (u, h) => (S(), I(X, { key: h }, [
        (S(!0), I(X, null, Q(u.edges, (f, r) => (S(), W(vr, {
          key: r,
          "edge-id": r,
          edge: f,
          state: M(e)[r]
        }, {
          default: te((l) => [
            K(a.$slots, "edge-label", ne({ ref_for: !0 }, l))
          ]),
          _: 2
        }, 1032, ["edge-id", "edge", "state"]))), 128))
      ], 64))), 128)) : ae("", !0),
      a.enableEdgesLabel ? (S(!0), I(X, { key: 1 }, Q(i.value.summarized, (u, h) => (S(), W(gr, {
        key: h,
        edges: u.edges,
        state: M(e)[s(u)],
        "summarize-state": M(o)[s(u)]
      }, {
        default: te((f) => [
          K(a.$slots, "edges-label", ne({ ref_for: !0 }, f))
        ]),
        _: 2
      }, 1032, ["edges", "state", "summarize-state"]))), 128)) : ae("", !0)
    ]));
  }
}), yr = /* @__PURE__ */ U({
  __name: "VEdgeLabelsLayer",
  props: {
    enableEdgeLabel: { type: Boolean, default: !1 },
    enableEdgesLabel: { type: Boolean, default: !1 }
  },
  setup(n) {
    return (e, t) => (S(), W(br, {
      "enable-edge-label": e.enableEdgeLabel,
      "enable-edges-label": e.enableEdgesLabel,
      class: "v-ng-layer-edge-labels v-ng-graph-objects"
    }, Zt({ _: 2 }, [
      e.enableEdgeLabel ? {
        name: "edge-label",
        fn: te((o) => [
          K(e.$slots, "edge-label", Ot(zt(o)))
        ]),
        key: "0"
      } : void 0,
      e.enableEdgesLabel ? {
        name: "edges-label",
        fn: te((o) => [
          K(e.$slots, "edges-label", Ot(zt(o)))
        ]),
        key: "1"
      } : void 0
    ]), 1032, ["enable-edge-label", "enable-edges-label"]));
  }
}), wr = /* @__PURE__ */ U({
  __name: "VNodeFocusRing",
  props: {
    id: {},
    state: {},
    pos: { default: void 0 }
  },
  setup(n) {
    const e = n, t = O(() => {
      var a;
      return ((a = e.pos) == null ? void 0 : a.x) || 0;
    }), o = O(() => {
      var a;
      return ((a = e.pos) == null ? void 0 : a.y) || 0;
    }), i = lt(), s = Ee({});
    return ue(() => {
      var c, u, h;
      const a = e.state.shape;
      if (a.type === "circle") {
        const f = {
          type: "circle",
          radius: a.radius + ((c = a.strokeWidth) != null ? c : 0) / 2 + i.focusring.padding + i.focusring.width / 2,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, f);
      } else {
        const f = {
          type: "rect",
          width: a.width + ((u = a.strokeWidth) != null ? u : 0) + i.focusring.padding * 2 + i.focusring.width,
          height: a.height + ((h = a.strokeWidth) != null ? h : 0) + i.focusring.padding * 2 + i.focusring.width,
          borderRadius: a.borderRadius > 0 ? a.borderRadius + i.focusring.padding : 0,
          color: "none",
          strokeWidth: i.focusring.width,
          strokeColor: i.focusring.color,
          strokeDasharray: i.focusring.dasharray
        };
        Object.assign(s, f);
      }
    }), (a, c) => (S(), W(ft, {
      class: "v-ng-node-focusring",
      "base-x": t.value,
      "base-y": o.value,
      config: s
    }, null, 8, ["base-x", "base-y", "config"]));
  }
}), Er = { class: "v-ng-layer-nodes-selections" }, kr = /* @__PURE__ */ U({
  __name: "VFocusringLayer",
  setup(n) {
    const { nodeStates: e } = me(), { selectedNodes: t } = ms(), o = Kt();
    return (i, s) => (S(), I("g", Er, [
      (S(!0), I(X, null, Q(M(t), (a) => (S(), W(wr, {
        id: a,
        key: a,
        state: M(e)[a],
        pos: M(o).nodes[a]
      }, null, 8, ["id", "state", "pos"]))), 128))
    ]));
  }
}), xr = ["transform"], zn = /* @__PURE__ */ U({
  __name: "VNode",
  props: {
    id: {},
    state: {},
    pos: { default: void 0 }
  },
  setup(n) {
    const e = n, t = O(() => {
      var r;
      return ((r = e.pos) == null ? void 0 : r.x) || 0;
    }), o = O(() => {
      var r;
      return ((r = e.pos) == null ? void 0 : r.y) || 0;
    }), { scale: i } = de(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: a,
      handleNodePointerOutEvent: c,
      handleNodeClickEvent: u,
      handleNodeDoubleClickEvent: h,
      handleNodeContextMenu: f
    } = Ye();
    return (r, l) => (S(), I("g", {
      class: ce({ "v-ng-node": !0, hover: r.state.hovered, selected: r.state.selected }),
      transform: `translate(${t.value} ${o.value})`,
      onPointerdown: l[0] || (l[0] = ve((d) => M(s)(r.id, d), ["stop"])),
      onPointerenterPassive: l[1] || (l[1] = (d) => M(a)(r.id, d)),
      onPointerleavePassive: l[2] || (l[2] = (d) => M(c)(r.id, d)),
      onClick: l[3] || (l[3] = ve((d) => M(u)(r.id, d), ["stop"])),
      onDblclick: l[4] || (l[4] = ve((d) => M(h)(r.id, d), ["stop"])),
      onContextmenu: l[5] || (l[5] = (d) => M(f)(r.id, d))
    }, [
      K(r.$slots, "override-node", {
        nodeId: r.id,
        scale: M(i),
        config: r.state.shape,
        class: ce({ draggable: r.state.draggable, selectable: r.state.selectable })
      }, () => [
        Ie(ft, {
          config: r.state.shape,
          class: ce({
            "v-ng-node-default": !0,
            draggable: r.state.draggable,
            selectable: r.state.selectable
          })
        }, null, 8, ["config", "class"])
      ])
    ], 42, xr));
  }
}), Pr = /* @__PURE__ */ U({
  __name: "VNodesLayer",
  setup(n) {
    const e = st(), t = O(() => "override-node" in e), { nodeZOrderedList: o } = me(), i = lt(), s = Kt();
    return (a, c) => t.value ? (S(), W(Fe, {
      key: 0,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes v-ng-graph-objects"
    }, {
      default: te(() => [
        (S(!0), I(X, null, Q(M(o), (u) => (S(), W(zn, {
          id: u.id,
          key: u.id,
          state: u,
          pos: M(s).nodes[u.id]
        }, {
          "override-node": te((h) => [
            K(a.$slots, "override-node", ne({ ref_for: !0 }, h))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (S(), W(Fe, {
      key: 1,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-nodes v-ng-graph-objects"
    }, {
      default: te(() => [
        (S(!0), I(X, null, Q(M(o), (u) => (S(), W(zn, {
          id: u.id,
          key: u.id,
          state: u,
          pos: M(s).nodes[u.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), co = {
  [D.NORTH]: 0,
  [D.NORTH_EAST]: 1,
  [D.EAST]: 2,
  [D.SOUTH_EAST]: 3,
  [D.SOUTH]: 4,
  [D.SOUTH_WEST]: 5,
  [D.WEST]: 6,
  [D.NORTH_WEST]: 7,
  [D.CENTER]: -1
}, Sr = [
  /* N */
  (n, e) => ke(n, 0, e ? 90 : 60),
  /* NE */
  (n, e) => ke(n, 45, e ? 90 : 45),
  /* E */
  (n, e) => ke(n, 90, e ? 60 : 30),
  /* SE */
  (n, e) => ke(n, 135, e ? 90 : 45),
  /* S */
  (n, e) => ke(n, 180, e ? 90 : 60),
  /* SW */
  (n, e) => ke(n, 225, e ? 90 : 45),
  /* W */
  (n, e) => ke(n, 270, e ? 60 : 30),
  /* NW */
  (n, e) => ke(n, 315, e ? 90 : 45)
];
function Mr(n, e, t, o, i) {
  if (i === D.CENTER)
    return D.CENTER;
  const s = [];
  Object.entries(t).forEach(([h, f]) => {
    let r = !1;
    if (f.nodeId === n) {
      const d = o(h);
      d && (r = !0, f = Be(oe({}, f), {
        pos: { x: d.x, y: d.y }
      }));
    }
    const l = (Ut(jt(f.pos, e)) + 360 + 90) % 360;
    s.push([l, r]);
  });
  const a = Cr(i), u = [
    a,
    (a + 4) % 8,
    // priority is given to diagonals
    (a + 2) % 8,
    (a - 2 + 8) % 8,
    (a + 1) % 8,
    (a - 1 + 8) % 8,
    (a + 3) % 8,
    (a - 3 + 8) % 8
  ].find((h) => s.every((f) => !Sr[h](...f)));
  return u === void 0 ? i : Or(u, i);
}
function ke(n, e, t) {
  n %= 360;
  const o = (e - t + 360) % 360, i = (e + t) % 360;
  return o <= i ? o < n && n < i : o < n || n < i;
}
function Cr(n) {
  var e;
  return (e = co[n]) != null ? e : 0;
}
function Or(n, e) {
  var t, o;
  return (o = (t = Object.entries(co)[n]) == null ? void 0 : t[0]) != null ? o : e;
}
const zr = ["transform"], Tn = /* @__PURE__ */ U({
  __name: "VNodeLabel",
  props: {
    id: {},
    state: {},
    pos: { default: void 0 }
  },
  setup(n) {
    const e = n, t = lt(), { edgeStates: o } = me(), { scale: i } = de(), {
      handleNodePointerDownEvent: s,
      handleNodePointerOverEvent: a,
      handleNodePointerOutEvent: c,
      handleNodeClickEvent: u,
      handleNodeDoubleClickEvent: h,
      handleNodeContextMenu: f
    } = Ye(), r = O(() => {
      var C;
      return ((C = e.pos) == null ? void 0 : C.x) || 0;
    }), l = O(() => {
      var C;
      return ((C = e.pos) == null ? void 0 : C.y) || 0;
    }), d = O(() => e.state.label.direction === D.CENTER ? 0 : e.state.label.margin * i.value), b = j(0), k = j(0), g = j(0), v = j(0), w = O(() => {
      var N;
      const C = e.state.label.direction, T = e.state.label.directionAutoAdjustment;
      if (T === !1)
        return C;
      const $ = { x: r.value, y: l.value };
      return T === !0 ? Mr(
        e.state.id,
        $,
        e.state.oppositeNodes,
        (G) => {
          var B, H;
          return (H = (B = o[G]) == null ? void 0 : B.loop) == null ? void 0 : H.center;
        },
        C
      ) : (N = T({
        nodeId: e.state.id,
        pos: $,
        oppositeNodes: e.state.oppositeNodes
      })) != null ? N : C;
    }), E = O(() => {
      switch (w.value) {
        case D.CENTER:
        case D.NORTH:
        case D.SOUTH:
          return "middle";
        case D.EAST:
        case D.NORTH_EAST:
        case D.SOUTH_EAST:
          return "start";
        case D.WEST:
        case D.NORTH_WEST:
        case D.SOUTH_WEST:
        default:
          return "end";
      }
    }), m = O(() => {
      switch (w.value) {
        case D.NORTH:
        case D.NORTH_EAST:
        case D.NORTH_WEST:
          return "text-top";
        case D.SOUTH:
        case D.SOUTH_EAST:
        case D.SOUTH_WEST:
          return "hanging";
        case D.CENTER:
        case D.EAST:
        case D.WEST:
        default:
          return "central";
      }
    }), p = O(() => {
      switch (w.value) {
        case D.CENTER:
        case D.NORTH:
        case D.SOUTH:
          return 0;
        case D.EAST:
          return k.value;
        case D.WEST:
          return -k.value;
        case D.NORTH_EAST:
        case D.SOUTH_EAST:
          return v.value;
        case D.NORTH_WEST:
        case D.SOUTH_WEST:
        default:
          return -v.value;
      }
    }), y = O(() => {
      switch (w.value) {
        case D.NORTH:
          return -b.value;
        case D.SOUTH:
          return b.value;
        case D.CENTER:
        case D.EAST:
        case D.WEST:
          return 0;
        case D.NORTH_EAST:
        case D.NORTH_WEST:
          return -g.value;
        case D.SOUTH_EAST:
        case D.SOUTH_WEST:
        default:
          return g.value;
      }
    });
    ue(() => {
      const C = i.value, T = e.state.shape;
      if (T.type == "circle") {
        const $ = T.radius * C, N = $ + d.value, G = Math.sqrt(ie(N, 2) / 2);
        b.value = $ + d.value, k.value = $ + d.value, g.value = G, v.value = G;
      } else {
        const $ = T.borderRadius * C, N = T.width * C, G = T.height * C, B = $ + d.value, H = Math.sqrt(ie(B, 2) / 2);
        b.value = G / 2 + d.value, k.value = N / 2 + d.value, g.value = G / 2 - $ + H, v.value = N / 2 - $ + H;
      }
    });
    const x = O(() => (C) => t.label.handleNodeEvents ? {
      pointerdown: (T) => {
        T.stopPropagation(), s(C, T);
      },
      pointerenter: (T) => a(C, T),
      pointerleave: (T) => c(C, T),
      click: (T) => {
        T.stopPropagation(), u(C, T);
      },
      dblclick: (T) => {
        T.stopPropagation(), h(C, T);
      },
      contextmenu: (T) => {
        f(C, T);
      }
    } : {}), z = O(() => {
      const C = t.label.handleNodeEvents;
      return {
        "v-ng-node-label": !0,
        hover: C && e.state.hovered,
        selected: C && e.state.selected
      };
    }), L = O(() => {
      const C = t.label.handleNodeEvents;
      return {
        draggable: C && e.state.draggable,
        selectable: C && e.state.selectable
      };
    });
    return (C, T) => (S(), I("g", ne({
      class: z.value,
      transform: `translate(${r.value} ${l.value})`
    }, Bo(x.value(C.id), !0)), [
      K(C.$slots, "override-node-label", {
        nodeId: C.id,
        scale: M(i),
        text: C.state.labelText,
        x: p.value,
        y: y.value,
        config: C.state.label,
        shape: C.state.shape,
        textAnchor: E.value,
        dominantBaseline: m.value,
        class: ce(L.value)
      }, () => [
        Ie(ht, {
          text: C.state.labelText,
          x: 0,
          y: 0,
          config: C.state.label,
          "text-anchor": E.value,
          "dominant-baseline": m.value,
          class: ce(L.value),
          transform: `translate(${p.value} ${y.value})`
        }, null, 8, ["text", "config", "text-anchor", "dominant-baseline", "class", "transform"])
      ])
    ], 16, zr));
  }
}), Tr = /* @__PURE__ */ U({
  __name: "VNodeLabelsLayer",
  setup(n) {
    const e = st(), t = O(() => "override-node-label" in e), { nodeZOrderedList: o } = me(), i = lt(), s = Kt(), a = O(() => c(o.value));
    function c(u) {
      return u.filter((h) => {
        var f;
        return h.label.visible && ((f = h.labelText) != null ? f : !1);
      });
    }
    return (u, h) => t.value ? (S(), W(Fe, {
      key: 0,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels v-ng-graph-objects"
    }, {
      default: te(() => [
        (S(!0), I(X, null, Q(a.value, (f) => (S(), W(Tn, {
          id: f.id,
          key: f.id,
          state: f,
          pos: M(s).nodes[f.id]
        }, {
          "override-node-label": te((r) => [
            K(u.$slots, "override-node-label", ne({ ref_for: !0 }, r))
          ]),
          _: 2
        }, 1032, ["id", "state", "pos"]))), 128))
      ]),
      _: 3
    }, 8, ["name", "css"])) : (S(), W(Fe, {
      key: 1,
      name: M(i).transition,
      css: !!M(i).transition,
      tag: "g",
      class: "v-ng-layer-node-labels v-ng-graph-objects"
    }, {
      default: te(() => [
        (S(!0), I(X, null, Q(a.value, (f) => (S(), W(Tn, {
          id: f.id,
          key: f.id,
          state: f,
          pos: M(s).nodes[f.id]
        }, null, 8, ["id", "state", "pos"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), _r = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"], Ir = /* @__PURE__ */ U({
  __name: "VPath",
  props: {
    path: {}
  },
  setup(n) {
    const e = n, { nodeStates: t, edgeStates: o, layouts: i } = me(), { scale: s } = de(), a = Nn();
    function c(l) {
      if (l.edges.length === 0) return [];
      const d = _.value(a.margin, l.path) * s.value;
      return vi(
        l,
        t,
        i.nodes,
        o,
        s.value,
        a.curveInNode,
        a.end,
        d
      );
    }
    function u(l) {
      const d = c(l);
      let b = !0;
      return d.map((k) => {
        if (k === null)
          b = !0;
        else {
          if (typeof k == "string")
            return k;
          if (k instanceof Array) {
            k = [...k];
            const g = [];
            if (k.length % 2 === 1) {
              const v = k[0];
              k = k.slice(1), g.push(`L ${v.x} ${v.y}`);
            }
            return Dt(k, 2).map(([v, w]) => g.push(`Q ${v.x} ${v.y} ${w.x} ${w.y}`)), g.join(" ");
          } else {
            const g = b;
            return b = !1, `${g ? "M " : "L "}${k.x} ${k.y}`;
          }
        }
      }).join(" ");
    }
    const h = O(() => {
      const l = e.path;
      return l.selected ? _.values(a.selected, l.path) : l.hovered && a.hover ? _.values(a.hover, l.path) : _.values(a.normal, l.path);
    }), f = O(() => Ke(h.value.dasharray, s.value)), r = O(() => {
      const l = h.value.animate ? rt(h.value.dasharray) * h.value.animationSpeed * s.value : !1;
      return l ? { "--animation-speed": l } : void 0;
    });
    return (l, d) => (S(), I("path", {
      class: ce({
        "v-ng-path": !0,
        animate: h.value.animate,
        clickable: l.path.clickable,
        hoverable: l.path.hoverable
      }),
      d: u(l.path),
      fill: "none",
      stroke: h.value.color,
      "stroke-width": h.value.width * M(s),
      "stroke-dasharray": f.value,
      "stroke-linecap": h.value.linecap,
      "stroke-linejoin": h.value.linejoin,
      style: Ge(r.value)
    }, null, 14, _r));
  }
}), Lr = /* @__PURE__ */ U({
  __name: "VPaths",
  setup(n) {
    const { pathZOrderedList: e } = me(), t = Nn(), {
      handlePathPointerDownEvent: o,
      handlePathPointerOverEvent: i,
      handlePathPointerOutEvent: s,
      handlePathClickEvent: a,
      handlePathDoubleClickEvent: c,
      handlePathContextMenu: u
    } = Ye();
    return (h, f) => (S(), W(Fe, {
      name: M(t).transition,
      css: !!M(t).transition,
      tag: "g",
      class: "v-ng-paths v-ng-layer-paths v-ng-graph-objects"
    }, {
      default: te(() => [
        (S(!0), I(X, null, Q(M(e), (r) => (S(), W(Ir, {
          key: r.id,
          path: r,
          onPointerdown: (l) => M(o)(r.id, l),
          onPointerenterPassive: (l) => M(i)(r.id, l),
          onPointerleavePassive: (l) => M(s)(r.id, l),
          onClick: ve((l) => M(a)(r.id, l), ["stop"]),
          onDblclick: ve((l) => M(c)(r.id, l), ["stop"]),
          onContextmenu: (l) => M(u)(r.id, l)
        }, null, 8, ["path", "onPointerdown", "onPointerenterPassive", "onPointerleavePassive", "onClick", "onDblclick", "onContextmenu"]))), 128))
      ]),
      _: 1
    }, 8, ["name", "css"]));
  }
}), $r = /* @__PURE__ */ U({
  __name: "VPathsLayer",
  setup(n) {
    return (e, t) => (S(), W(Lr));
  }
}), Ar = { key: 0 }, Zr = /* @__PURE__ */ U({
  __name: "VNetworkGraph",
  props: {
    nodes: { default: () => ({}) },
    edges: { default: () => ({}) },
    paths: { default: () => ({}) },
    layouts: { default: () => ({}) },
    zoomLevel: { default: 1 },
    selectedNodes: { default: () => [] },
    selectedEdges: { default: () => [] },
    selectedPaths: { default: () => [] },
    configs: { default: () => ({}) },
    layers: { default: () => ({}) },
    eventHandlers: { default: () => ({}) }
  },
  emits: ["update:zoomLevel", "update:selectedNodes", "update:selectedEdges", "update:selectedPaths", "update:layouts"],
  setup(n, { expose: e, emit: t }) {
    const o = [
      "override-node",
      "override-node-label",
      "edge-overlay",
      "edge-label",
      "edges-label"
    ], i = n, s = t, a = st(), c = we(i, "nodes"), u = we(i, "edges"), { objects: h, isInCompatibilityModeForPath: f } = ps(
      we(i, "paths")
    ), r = Qi();
    Object.entries(i.eventHandlers).forEach(([P, Z]) => {
      r.on(P, Z);
    });
    const l = Go(we(i, "configs")), d = O(() => {
      const P = new Set(Object.keys(a));
      o.forEach((A) => P.delete(A));
      const Z = Object.fromEntries(Uo.map((A) => [A, []]));
      return Object.assign(
        Z,
        Object.entries(i.layers).reduce(
          (A, [V, ee]) => (P.delete(V), ee in A ? A[ee].push(V) : A[ee] = [V], A),
          {}
        )
      ), Z.root.push(...P), Z;
    }), b = O(() => l.view.grid.visible), k = O(() => {
      const P = d.value;
      return b.value || P.background.length > 0 || P.grid.length > 0;
    }), g = Es(l, a), v = j(), w = j(), E = j(), m = j(
      0
      /* INITIAL */
    ), p = O(
      () => m.value !== 0
      /* INITIAL */
    ), y = vs(i, "zoomLevel", s, (P) => (P = Math.max(P, l.view.minZoomLevel), P = Math.min(P, l.view.maxZoomLevel), P)), { svgPanZoom: x, onSvgPanZoomMounted: z, onSvgPanZoomUnmounted: L } = us(w, {
      viewportSelector: ".v-ng-viewport",
      minZoom: l.view.minZoomLevel,
      // temporary
      maxZoom: l.view.maxZoomLevel,
      // temporary
      dblClickZoomEnabled: tn(l.view),
      mouseWheelZoomEnabled: gt(l.view),
      fit: l.view.autoPanAndZoomOnLoad === "fit-content",
      center: l.view.autoPanAndZoomOnLoad !== !1,
      zoomEnabled: l.view.zoomEnabled,
      preventMouseEventsDefault: !1,
      onZoom: (P) => {
        var A, V;
        if (m.value === 2) return;
        const Z = (V = (A = x.value) == null ? void 0 : A.getRealZoom()) != null ? V : 1;
        Math.abs(y.value - Z) >= 1e-6 && (y.value = Z, r.emit("view:zoom", Z));
      },
      panEnabled: l.view.panEnabled,
      onPan: (P) => {
        m.value !== 2 && r.emit("view:pan", P);
      }
    });
    Fo({ container: v, svg: w, viewport: E, svgPanZoom: x });
    const C = { width: 0, height: 0 }, T = globalThis.ResizeObserver ? new ResizeObserver(() => {
      var Z, A, V;
      if ((Z = x.value) == null || Z.resize(), !l.view.autoPanOnResize) return;
      const P = (A = v.value) == null ? void 0 : A.getBoundingClientRect();
      if (P) {
        const ee = -(C.width - P.width) / 2, Te = -(C.height - P.height) / 2;
        (V = x.value) == null || V.panBy({ x: ee, y: Te });
        const { width: ye, height: mt } = P;
        (C.width !== ye || C.height !== mt) && (Object.assign(C, { width: ye, height: mt }), r.emit("view:resize", { x: P.x, y: P.y, width: ye, height: mt }));
      }
    }) : void 0;
    z(() => {
      var ee, Te, ye;
      const P = q(v.value, "svg-pan-zoom container");
      T == null || T.observe(P), (Te = (ee = l.view).onSvgPanZoomInitialized) == null || Te.call(ee, q(x.value, "svg-pan-zoom instance"));
      const Z = P.getBoundingClientRect(), { width: A, height: V } = Z;
      Object.assign(C, { width: A, height: V }), (ye = E.value) == null || ye.addEventListener("touchstart", nn, { passive: !1 });
    }), L(() => {
      var P;
      T == null || T.disconnect(), (P = E.value) == null || P.removeEventListener("touchstart", nn);
    });
    const $ = (P) => {
      var Z;
      (Z = x.value) == null || Z.applyAbsoluteZoomLevel(
        P,
        l.view.minZoomLevel,
        l.view.maxZoomLevel
      );
    };
    F(
      () => l.view.panEnabled,
      (P) => {
        var Z;
        (Z = x.value) == null || Z.setPanEnabled(P);
      }
    ), F(
      () => [
        l.view.zoomEnabled,
        tn(l.view),
        gt(l.view)
      ],
      () => {
        const P = x.value;
        P && _o(
          P,
          l.view.zoomEnabled,
          l.view.doubleClickZoomEnabled,
          l.view.mouseWheelZoomEnabled
        );
      }
    ), F(y, (P) => $(P)), F(
      () => [l.view.minZoomLevel, l.view.maxZoomLevel],
      (P) => {
        $(y.value);
      }
    );
    const { scale: N } = ds(y, l.view);
    z(() => {
      const P = i.zoomLevel;
      $(P);
    });
    const G = () => pe(this, null, function* () {
      var P;
      Object.keys(i.nodes).length > 0 && ((P = x.value) == null || P.updateBBox(), yield Cn());
    }), B = (P) => pe(this, null, function* () {
      var Te, ye;
      const Z = !P || P.margin === void 0 ? l.view.fitContentMargin : P.margin;
      yield G();
      const A = q(w.value).getBoundingClientRect(), V = Os(Z, A), ee = zs(
        q(E.value),
        A,
        be.nodes,
        y.value,
        V,
        l.view.scalingObjects
      );
      ee ? ($(ee.zoom), (Te = x.value) == null || Te.pan(ee.pos)) : (ye = x.value) == null || ye.center(), r.emit("view:fit", void 0);
    }), H = () => pe(this, null, function* () {
      var P;
      yield G(), (P = x.value) == null || P.center();
    }), fe = () => {
      var P, Z;
      return (Z = (P = x.value) == null ? void 0 : P.getViewBox()) != null ? Z : {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }, se = (P) => {
      var Z;
      return (Z = x.value) == null ? void 0 : Z.setViewBox(P);
    }, ge = Ct(i, "selectedNodes", c, s);
    F(ge, (P) => r.emit("node:select", Array.from(P)));
    const Oe = Ct(i, "selectedEdges", u, s);
    F(Oe, (P) => r.emit("edge:select", Array.from(P)));
    const ze = Ct(i, "selectedPaths", h, s);
    F(ze, (P) => r.emit("path:select", Array.from(P))), gs(ge, Oe, ze);
    const re = xe(/* @__PURE__ */ new Set()), Le = xe(/* @__PURE__ */ new Set()), $e = xe(/* @__PURE__ */ new Set()), be = xe({ nodes: {} });
    bs(be), F(
      () => i.layouts,
      () => {
        var P;
        return Object.assign(be.nodes, (P = i.layouts.nodes) != null ? P : {});
      },
      { deep: !0, immediate: !0 }
    ), F(be, () => s("update:layouts", be), { deep: !0 });
    const pt = Ei(), vt = j(!1);
    r.on("node:dragstart", (P) => vt.value = !0), r.on("node:dragend", (P) => vt.value = !1), r.on("view:mode", (P) => {
      var Z, A, V, ee;
      l.view.panEnabled && (P === "default" ? (Z = x.value) == null || Z.enablePan() : (A = x.value) == null || A.disablePan()), l.view.zoomEnabled && (P === "default" ? (V = x.value) == null || V.enableZoom() : (ee = x.value) == null || ee.disableZoom());
    });
    const uo = O(() => l.view.panEnabled || l.view.zoomEnabled || l.node.draggable), { nodeStates: fo, edgeStates: ho, pathStates: po } = Mi(
      wt(c, ge, re),
      wt(u, Oe, Le),
      wt(h, ze, $e),
      Re(l),
      be,
      i.layouts,
      pt,
      N
    ), vo = O(() => gt(l.view)), { isBoxSelectionMode: go, selectionBox: Yt, startBoxSelection: mo, stopBoxSelection: bo } = Ki(
      w,
      Re(be),
      Re(y),
      fo,
      ho,
      po,
      ge,
      Oe,
      ze,
      re,
      Le,
      $e,
      f,
      vo,
      l,
      r
    ), Qt = () => ({
      layouts: xe(be.nodes),
      // deprecated parameter.
      nodePositions: we(be, "nodes"),
      nodes: c,
      edges: u,
      configs: Re(l),
      scale: Re(N),
      emitter: r,
      svgPanZoom: q(x.value)
    });
    F(
      () => l.view.layoutHandler,
      (P, Z) => {
        Z.deactivate(), P.activate(Qt());
      }
    );
    const { transitionWhile: yo, transitionOption: Jt } = hs(), wo = O(() => {
      const P = Jt.value;
      return P.enabled ? {
        "--transition-duration": P.duration + "ms",
        "--transition-function": P.timingFunction
      } : {};
    });
    z(() => pe(this, null, function* () {
      if (l.view.onBeforeInitialDisplay) {
        const A = l.view.onBeforeInitialDisplay();
        Jo(A) && (yield A);
      }
      const P = q(x.value, "svg-pan-zoom");
      l.view.layoutHandler.activate(Qt()), yield Cn();
      const Z = l.view.autoPanAndZoomOnLoad;
      if (l.view.fit || Z !== !1) {
        const A = Object.keys(i.nodes).length == 0, V = P.getPan();
        if (A || Z === "center-zero") {
          yield G();
          const ee = P.getSizes();
          P.pan({
            x: ee.width / 2,
            y: ee.height / 2
          });
        } else Z === "fit-content" || l.view.fit ? yield B() : Z === "center-content" ? yield H() : yield G();
        At(() => {
          const ee = P.getPan();
          V.x === ee.x && V.y === ee.y && r.emit("view:pan", ee);
        });
      } else
        yield G();
      r.emit("view:load"), m.value = 1;
    })), L(() => {
      m.value = 2, r.emit("view:unload"), l.view.layoutHandler.deactivate();
    });
    function Eo() {
      var P;
      (P = x.value) == null || P.zoomIn();
    }
    function ko() {
      var P;
      (P = x.value) == null || P.zoomOut();
    }
    function xo(P) {
      var Z;
      (Z = x.value) == null || Z.pan(P);
    }
    function Po(P) {
      var Z;
      (Z = x.value) == null || Z.panBy(P);
    }
    function So() {
      return q(x.value).getPan();
    }
    function Mo() {
      const P = q(x.value).getSizes();
      return {
        width: P.width,
        height: P.height,
        viewBox: P.viewBox
      };
    }
    function Co(P) {
      return $t(
        q(w.value, "svg"),
        q(E.value, "viewport"),
        P
      );
    }
    function Oo(P) {
      return Wi(
        q(w.value, "svg"),
        q(E.value, "viewport"),
        P
      );
    }
    function zo() {
      return Qn(
        q(w.value, "svg"),
        q(E.value, "viewport"),
        N.value
      ).outerHTML;
    }
    function To() {
      return pe(this, arguments, function* (P = {}) {
        return (yield en(P)).outerHTML;
      });
    }
    function en() {
      return pe(this, arguments, function* (P = {}) {
        return Ui(
          q(w.value, "svg"),
          q(E.value, "viewport"),
          N.value,
          P
        );
      });
    }
    e({
      // methods
      fitToContents: B,
      panToCenter: H,
      getViewBox: fe,
      setViewBox: se,
      transitionWhile: yo,
      startBoxSelection: mo,
      stopBoxSelection: bo,
      zoomIn: Eo,
      zoomOut: ko,
      panTo: xo,
      panBy: Po,
      getPan: So,
      getSizes: Mo,
      translateFromDomToSvgCoordinates: Co,
      translateFromSvgToDomCoordinates: Oo,
      getAsSvg: zo,
      exportAsSvgText: To,
      exportAsSvgElement: en
    });
    function _o(P, Z, A, V) {
      P.setZoomEnabled(Z), Z && A ? P.enableDblClickZoom() : P.disableDblClickZoom(), Z && V ? P.enableMouseWheelZoom() : P.disableMouseWheelZoom();
    }
    function tn(P) {
      return P.zoomEnabled && P.doubleClickZoomEnabled;
    }
    function gt(P) {
      return P.zoomEnabled && P.mouseWheelZoomEnabled;
    }
    function nn(P) {
      P.stopPropagation();
    }
    return (P, Z) => (S(), I("div", {
      ref_key: "container",
      ref: v,
      class: "v-network-graph v-ng-container"
    }, [
      (S(), I("svg", {
        ref_key: "svg",
        ref: w,
        class: ce(["v-ng-canvas", { show: p.value, dragging: vt.value, touches: uo.value, "box-selection-mode": M(go) }]),
        width: "100%",
        height: "100%"
      }, [
        (S(!0), I(X, null, Q(d.value.root, (A) => K(P.$slots, A, {
          key: A,
          scale: M(N)
        })), 128)),
        Object.keys(M(pt).markers).length > 0 ? (S(), I("defs", Ar, [
          (S(!0), I(X, null, Q(M(pt).markers, (A, V) => (S(), W(Vs, {
            id: V,
            key: V,
            marker: A,
            scale: M(N)
          }, null, 8, ["id", "marker", "scale"]))), 128))
        ])) : ae("", !0),
        k.value ? (S(), W(Gs, { key: 1 }, {
          default: te(() => [
            (S(!0), I(X, null, Q(d.value.background, (A) => (S(), I("g", {
              key: A,
              class: "v-ng-layer"
            }, [
              K(P.$slots, A, { scale: M(N) })
            ]))), 128)),
            b.value ? (S(), W(Xs, { key: 0 })) : ae("", !0),
            (S(!0), I(X, null, Q(d.value.grid, (A) => (S(), I("g", {
              key: A,
              class: "v-ng-layer"
            }, [
              K(P.$slots, A, { scale: M(N) })
            ]))), 128))
          ]),
          _: 3
        })) : ae("", !0),
        In("g", {
          ref_key: "viewport",
          ref: E,
          class: ce(["v-ng-viewport", { "v-ng-transition": M(Jt).enabled }]),
          style: Ge(wo.value)
        }, [
          (S(!0), I(X, null, Q(d.value.base, (A) => (S(), I("g", {
            key: A,
            class: "v-ng-layer"
          }, [
            K(P.$slots, A, { scale: M(N) })
          ]))), 128)),
          (S(!0), I(X, null, Q(M(g), (A) => (S(), I(X, { key: A }, [
            A === "edges" ? (S(), W(pr, { key: 0 }, Zt({ _: 2 }, [
              "edge-overlay" in a ? {
                name: "edge-overlay",
                fn: te((V) => [
                  K(P.$slots, "edge-overlay", ne({ ref_for: !0 }, V))
                ]),
                key: "0"
              } : void 0
            ]), 1024)) : A === "edge-labels" ? (S(), W(yr, {
              key: 1,
              "enable-edge-label": "edge-label" in a,
              "enable-edges-label": "edges-label" in a
            }, {
              "edge-label": te((V) => [
                K(P.$slots, "edge-label", ne({ ref_for: !0 }, V))
              ]),
              "edges-label": te((V) => [
                K(P.$slots, "edges-label", ne({ ref_for: !0 }, V))
              ]),
              _: 3
            }, 8, ["enable-edge-label", "enable-edges-label"])) : A === "focusring" ? (S(), W(kr, { key: 2 })) : A === "nodes" ? (S(), W(Pr, { key: 3 }, {
              "override-node": te((V) => [
                K(P.$slots, "override-node", ne({ ref_for: !0 }, V))
              ]),
              _: 3
            })) : A === "node-labels" ? (S(), W(Tr, { key: 4 }, {
              "override-node-label": te((V) => [
                K(P.$slots, "override-node-label", ne({ ref_for: !0 }, V))
              ]),
              _: 3
            })) : A === "paths" ? (S(), W($r, { key: 5 })) : ae("", !0),
            (S(!0), I(X, null, Q(d.value[A], (V) => (S(), I("g", {
              key: V,
              class: "v-ng-layer"
            }, [
              K(P.$slots, V, { scale: M(N) })
            ]))), 128))
          ], 64))), 128))
        ], 6),
        M(Yt) ? (S(), W($s, {
          key: 2,
          box: M(Yt),
          config: M(l).view.selection.box
        }, null, 8, ["box", "config"])) : ae("", !0)
      ], 2))
    ], 512));
  }
}), Dr = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [o, i] of e)
    t[o] = i;
  return t;
}, Nr = {};
function jr(n, e) {
  return S(), I("defs", null, [
    (S(), W(_n("style"), null, {
      default: te(() => [
        K(n.$slots, "default")
      ]),
      _: 3
    }))
  ]);
}
const Br = /* @__PURE__ */ Dr(Nr, [["render", jr]]), Rr = /* @__PURE__ */ U({
  __name: "VEdgeLabel",
  props: {
    area: {},
    config: {},
    text: { default: "" },
    align: { default: "center" },
    verticalAlign: { default: "center" },
    edge: { default: void 0 },
    hovered: { type: Boolean, default: void 0 },
    selected: { type: Boolean, default: void 0 },
    scale: { default: void 0 }
  },
  setup(n) {
    const e = n, t = j(0), o = j(0), i = j("middle"), s = j("central"), a = j(0);
    ue(() => {
      const u = e.area.source, h = e.area.target;
      e.align === "source" ? (u.above.x == h.above.x ? i.value = u.above.y > h.above.y ? "start" : "end" : i.value = u.above.x < h.above.x ? "start" : "end", e.verticalAlign === "above" ? (t.value = u.above.x, o.value = u.above.y, s.value = "text-top") : e.verticalAlign === "below" ? (t.value = u.below.x, o.value = u.below.y, s.value = "hanging") : (t.value = (u.above.x + u.below.x) / 2, o.value = (u.above.y + u.below.y) / 2, s.value = "central")) : e.align === "target" ? (u.above.x == h.above.x ? i.value = u.above.y < h.above.y ? "start" : "end" : i.value = u.above.x > h.above.x ? "start" : "end", e.verticalAlign === "above" ? (t.value = h.above.x, o.value = h.above.y, s.value = "text-top") : e.verticalAlign === "below" ? (t.value = h.below.x, o.value = h.below.y, s.value = "hanging") : (t.value = (h.above.x + h.below.x) / 2, o.value = (h.above.y + h.below.y) / 2, s.value = "central")) : (i.value = "middle", e.verticalAlign === "above" ? (t.value = (u.above.x + h.above.x) / 2, o.value = (u.above.y + h.above.y) / 2, s.value = "text-top") : e.verticalAlign === "below" ? (t.value = (u.below.x + h.below.x) / 2, o.value = (u.below.y + h.below.y) / 2, s.value = "hanging") : (t.value = (u.above.x + h.below.x) / 2, o.value = (u.above.y + h.below.y) / 2, s.value = "central"));
      let f = Y.fromPositions(u.above, h.above).v.angleDegree();
      (f < -90 || f >= 90) && (f = f + 180, f > 180 && (f -= 360)), a.value = f;
    });
    const c = O(() => s.value === "central" && !e.config.background ? Be(oe({}, e.config), {
      background: {
        visible: !0,
        color: "#ffffff",
        padding: {
          vertical: 1,
          horizontal: 4
        },
        borderRadius: 2
      }
    }) : e.config);
    return (u, h) => (S(), W(ht, {
      class: "v-ng-edge-label",
      text: u.text,
      x: t.value,
      y: o.value,
      config: c.value,
      "text-anchor": i.value,
      "dominant-baseline": s.value,
      transform: `rotate(${a.value} ${t.value} ${o.value})`
    }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]));
  }
}), Vr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VEdgeLabel: Rr,
  VLabelText: ht,
  VNetworkGraph: Zr,
  VShape: ft,
  VStyle: Br
}, Symbol.toStringTag, { value: "Module" })), Wr = 10;
class Kr extends An {
  constructor(e = {}) {
    super(), this.options = e;
  }
  setNodePosition(e, t) {
    const o = this.options.grid || Wr;
    e.value.x = Math.floor(t.x / o) * o, e.value.y = Math.floor(t.y / o) * o;
  }
}
const Yr = function(n) {
  Object.entries(Vr).forEach(([e, t]) => {
    n.component(e, t);
  });
};
export {
  _ as Config,
  Kr as GridLayout,
  Uo as LayerPositions,
  D as NodeLabelDirection,
  An as SimpleLayout,
  Rr as VEdgeLabel,
  ht as VLabelText,
  Zr as VNetworkGraph,
  ft as VShape,
  Br as VStyle,
  R as Vector2D,
  qr as configsWithType,
  Yr as default,
  Xr as defineConfigs,
  Gr as getFullConfigs,
  me as useStates,
  bt as withSelf
};
//# sourceMappingURL=index.js.map
